<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhengrenjie blog</title>
  
  
  <link href="https://www.jelliclecat.cn/atom.xml" rel="self"/>
  
  <link href="https://www.jelliclecat.cn/"/>
  <updated>2021-06-25T13:47:33.057Z</updated>
  <id>https://www.jelliclecat.cn/</id>
  
  <author>
    <name>zhengrenjie</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从Mysql不走索引看InnoDB的索引原理</title>
    <link href="https://www.jelliclecat.cn/articles/Mysql/Mysql-1/"/>
    <id>https://www.jelliclecat.cn/articles/Mysql/Mysql-1/</id>
    <published>2020-03-20T14:29:53.000Z</published>
    <updated>2021-06-25T13:47:33.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="有索引的情况下，Mysql还是扫表，怎么回事"><a href="#有索引的情况下，Mysql还是扫表，怎么回事" class="headerlink" title="有索引的情况下，Mysql还是扫表，怎么回事"></a>有索引的情况下，Mysql还是扫表，怎么回事</h2><p>今天碰到一个这个问题：在where语句中有一个字段可以走<strong>二级索引去范围查</strong>的情况下，发现mysql并没有走索引，而是扫表。不知道大家有没有遇到过这个问题，并产生疑问。</p><p>为什么mysql在明明有索引的情况下却选择不走索引，而选择扫表呢？今天我们从InnoDB的索引原理讲一下为什么会出现这种现象。</p><h2 id="InnoDB索引原理"><a href="#InnoDB索引原理" class="headerlink" title="InnoDB索引原理"></a>InnoDB索引原理</h2><p>InnoDB对于PK的索引策略和二级索引的策略是不一样的。</p><p><em>部分知识来自于《高性能MySQL》，以及我自己的理解，本人没有看过源码，所以大家对内容要自行甄别对错</em></p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>InnoDB的索引数据结构是B树，更准确的说是B+树。为什么是B+树呢？因为B+树叶子节点不带数据，所以存储索引数据可以使用更少的磁盘存储空间，那么在PageCache读盘的时候，预读可以一次读取更多的索引数据，从而使用更少的磁盘IO就可以查询到更多的索引数据，这样就可以更快的定位到数据位置。</p><h3 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h3><p>一张表只能由唯一的聚集索引。一般PK上的索引会自动被设置为聚集索引（但是你也可以先创建聚集索引，再创建PK，大多数情况下，PK索引就是聚集索引）。之所以叫聚集索引，是因为所有叶子节点上的记录都紧凑的按主键顺序存储在磁盘上。由于这个特点，使用主键自增会获得很好的写性能，因为是顺序写。</p><h3 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h3><p>二级索引和PK索引不一样，虽然数据结构也是B+树，但是叶子节点上的数据记录的是PK的值，而不是实际的数据，所以在使用二级索引查找到的实际是二级索引对应的PK索引。</p><p>这样会导致一个问题，就是对于二级索引上的范围查找，会导致大量的随机读IO。因为首先根据二级索引查找到的是一批离散的PK，然后再根据这些PK去查找记录，这时候会发生随机读IO，并且还带来了logn的额外查询时间。</p><p>这种索引称为覆盖索引。</p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>上面说到二级索引范围查找带来的随机IO现象，再有一种情况下不会发生，那就是SELECT的字段只有PK和二级索引的列，由于二级索引的叶子节点上保存的就是PK数据，并且二级索引中就保存了列的值，所以这时候不需要再回到PK索引上查找。</p><p>所以，如果我们SELECT中的列都有对应的索引存在的话，那么会提升查找效率，因为不需要去真正的记录里面去查找数据，只用在索引数据里面查找就行了。</p><h2 id="回答问题"><a href="#回答问题" class="headerlink" title="回答问题"></a>回答问题</h2><p>好了，对索引原理有一个大致的了解。</p><p>那么为什么有时候，where语句里面明明有索引可走的情况下，mysql会选择扫表呢？原因就是扫表是顺序IO，而二级索引是先查找PK，然后再在PK索引中查找，是一个随机IO，外带一个logn的查询开销。</p><p>那么当<strong>二级索引范围查</strong>的扫描列大于一定的数量的时候，explain会发现，prossible_keys显示有索引可走，但是实际的key却没有走索引，type=ALL。</p><p>当逐渐缩小二级索引上的查找范围的时候，会发现，mysql会突然又选择去使用prossible_keys下显示的索引了。</p><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>举个例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `test` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `type` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  `status` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  `created_at` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `idx_create_at` (`created_at`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure><p>created_at列上有一个二级索引。</p><p>使用查询语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> test <span class="keyword">WHERE</span> type<span class="operator">=</span>? <span class="keyword">and</span> status<span class="operator">=</span>? <span class="keyword">and</span> created_at<span class="operator">&gt;</span><span class="string">&#x27;2020-01-01 00:00:00&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这时explain：</p><table><thead><tr><th align="center">select_type</th><th>type</th><th align="center">prossible_keys</th><th align="center">key</th><th align="center">Extra</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td>ALL</td><td align="center">idx_create_at</td><td align="center">NULL</td><td align="center">Using where</td></tr></tbody></table><p>可以看到有索引却没有走。</p><p>当我们缩小created_at的范围时：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> test <span class="keyword">WHERE</span> type<span class="operator">=</span>? <span class="keyword">and</span> status<span class="operator">=</span>? <span class="keyword">and</span> created_at<span class="operator">&gt;</span><span class="string">&#x27;2020-03-01 00:00:00&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这时explain：</p><table><thead><tr><th align="center">select_type</th><th>type</th><th align="center">prossible_keys</th><th align="center">key</th><th align="center">Extra</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td>range</td><td align="center">idx_create_at</td><td align="center">idx_create_at</td><td align="center">Using index condition; Using where</td></tr></tbody></table><p>发现同样一个语句，在范围查不同的情况下，有时候Mysql会选择不同的方式去进行实际的查找。</p><p>刚刚说过了，这种权衡是在较少的随机IO和较多的顺序IO这两者之间抉择的，<strong>并不是没有走索引性能就一定会差</strong>。</p><p>*<em>这里count(</em>)可以换成表中各个具体的列，但是不要用select <em>，这样不会走索引，原因我还不知道</em>*</p><h2 id="让mysql强制走索引"><a href="#让mysql强制走索引" class="headerlink" title="让mysql强制走索引"></a>让mysql强制走索引</h2><p>也很简单，查询分两步走：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> test <span class="keyword">as</span> a <span class="keyword">inner</span> <span class="keyword">join</span> test <span class="keyword">as</span> b <span class="keyword">on</span> a.id<span class="operator">=</span>b.id <span class="keyword">and</span> a.status<span class="operator">=</span>? <span class="keyword">AND</span> a.type<span class="operator">=</span>? <span class="keyword">AND</span> b.created_at<span class="operator">&gt;</span>&quot;2020-01-01 00:00:00&quot;;</span><br></pre></td></tr></table></figure><p>再次expain：</p><table><thead><tr><th align="center">select_type</th><th>table</th><th>type</th><th align="center">prossible_keys</th><th align="center">key</th><th align="center">Extra</th></tr></thead><tbody><tr><td align="center">SIMPLE</td><td>b</td><td>range</td><td align="center">PRIMARY,idx_create_at</td><td align="center">idx_create_at</td><td align="center">Using where; Using index</td></tr><tr><td align="center">SIMPLE</td><td>a</td><td>eq_ref</td><td align="center">PRIMARY</td><td align="center">PRIMARY</td><td align="center">Using where</td></tr></tbody></table><p>发现两次查询都走了索引。</p><p>并且使用idx_create_at二级索引的时候，还是用了覆盖索引，因为这一步只取出了PK。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;有索引的情况下，Mysql还是扫表，怎么回事&quot;&gt;&lt;a href=&quot;#有索引的情况下，Mysql还是扫表，怎么回事&quot; class=&quot;headerlink&quot; title=&quot;有索引的情况下，Mysql还是扫表，怎么回事&quot;&gt;&lt;/a&gt;有索引的情况下，Mysql还是扫表，怎么</summary>
      
    
    
    
    <category term="Mysql" scheme="https://www.jelliclecat.cn/categories/Mysql/"/>
    
    
    <category term="Mysql" scheme="https://www.jelliclecat.cn/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>聊透Spring-2-聊透Xml配置和注解的混用以及其原理</title>
    <link href="https://www.jelliclecat.cn/articles/Spring/spring-2/"/>
    <id>https://www.jelliclecat.cn/articles/Spring/spring-2/</id>
    <published>2019-11-21T14:29:53.000Z</published>
    <updated>2021-06-25T13:47:33.049Z</updated>
    
    <content type="html"><![CDATA[<h2 id="先看看AnnotationConfigApplicationContext"><a href="#先看看AnnotationConfigApplicationContext" class="headerlink" title="先看看AnnotationConfigApplicationContext"></a>先看看AnnotationConfigApplicationContext</h2><p>上篇博客我们讲了一下ClassPathXmlApplicationContext解析Xml的总体流程，没有深入到细节。ClassPathXmlApplicationContext负责解析Xml，对应Xml的spring启动方式，我们可以这样启动spring：</p><blockquote><p>ApplicationContext context = new ClassPathXmlApplicationContext(“applicationContext.xml”);</p></blockquote><p>相对应的AnnotationConfigApplicationContext代表的是以纯注解的方式启动spring：</p><blockquote><p>ApplicationContext context = new AnnotationConfigApplicationContext(“com.zrj”);</p></blockquote><p>这里传入的参数是扫描的Root包，spring会扫描这个包下的所有Class。</p><p>###AnnotationConfigApplicationContext启动spring</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AnnotationConfigApplicationContext.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationConfigApplicationContext</span> <span class="keyword">extends</span> <span class="title">GenericApplicationContext</span> <span class="keyword">implements</span> <span class="title">AnnotationConfigRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AnnotatedBeanDefinitionReader reader;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ClassPathBeanDefinitionScanner scanner;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.reader = <span class="keyword">new</span> AnnotatedBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.scanner = <span class="keyword">new</span> ClassPathBeanDefinitionScanner(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AnnotationConfigApplicationContext</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    scan(basePackages);</span><br><span class="line">    refresh();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>new AnnotationConfigApplicationContext(“com.nowcoder.spring”);</p></blockquote><p>这样创建的AnnotationConfigApplicationContext调用的是上面的构造函数（其他的构造函数不列举了，都差不多），这样构造出来后，创建了一个AnnotatedBeanDefinitionReader和一个ClassPathBeanDefinitionScanner，这个两个类非常的重要，AnnotationConfigApplicationContext所有的工作都交给了这两个类去完成。</p><p>看一下这个构造函数，首先调用this()初始化reader、scanner，然后调用scan，这是关键的一步，最终调用了ClassPathBeanDefinitionScanner#doScan方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">    Assert.notEmpty(basePackages, <span class="string">&quot;At least one base package must be specified&quot;</span>);</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">      Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">      <span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">        ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">        candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">        String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line">        <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">          postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">          AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">          BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">          definitionHolder =</span><br><span class="line">              AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">          beanDefinitions.add(definitionHolder);</span><br><span class="line">          registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>首先调用findCandidateComponents找到basePackage下所有的BeanDefinition，这个过程比较复杂，是通过ASM实现的，通过读取Class文件的字节码，拿到类的元信息。这里Spring可以说是一丝不苟，通过读取Class字节码的方式，让自己的扫描元信息的工作坚决不影响类的加载周期，换句话说这里完全不用对类进行任何的加载工作就能拿到类的元信息了。</p><p>找到所有的BeanDefinition后，工作就完成了一大半，Spring启动简单来说分两步走，第一步构建BeanDefinition作为Bean的候选人，第二步就是将BeanDefinition创建成一个个的Bean对象。</p><p>最后将BeanDefinition注册进BeanFactory中，等待Bean被创建。</p><p>在构造函数最后调用了refresh方法，这个方法和上篇博客中的ClassPathXmlApplicationContext里面调用的refresh是同一个方法，这里不再赘述了。</p><p>传送门：<a href="https://www.jelliclecat.cn/articles/Spring/spring-1.html">透Spring-1-ClassPathXmlApplicationContext</a></p><p>注意一点，AbstractRefreshableApplicationContext#refreshBeanFactory方法会调用loadBeanDefinitions，这是一个模板方法，在ClassPathXmlApplicationContext是有实现的，但是在AnnotationConfigApplicationContext是没有实现的，因为AnnotationConfigApplicationContext中BeanDefinition的扫描是交给ClassPathBeanDefinitionScanner去做的。</p><p>调用完doScan之后，调用了AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClassPathBeanDefinitionScanner.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">scan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> beanCountAtScanStart = <span class="keyword">this</span>.registry.getBeanDefinitionCount();</span><br><span class="line"></span><br><span class="line">  doScan(basePackages);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register annotation config processors, if necessary.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.includeAnnotationConfig) &#123;</span><br><span class="line">    AnnotationConfigUtils.registerAnnotationConfigProcessors(<span class="keyword">this</span>.registry);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">this</span>.registry.getBeanDefinitionCount() - beanCountAtScanStart);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法用于开启对注解的解析，这部分代码后面会讲解，我们还会遇到它的。includeAnnotationConfig这个配置默认是true。</p><h2 id="Xml和注解配置Spring混用是怎么实现的？"><a href="#Xml和注解配置Spring混用是怎么实现的？" class="headerlink" title="Xml和注解配置Spring混用是怎么实现的？"></a>Xml和注解配置Spring混用是怎么实现的？</h2><p>如果我们纯粹的使用Xml作为Spring的启动方式的话，那么全部bean的组装是有Xml文件控制的，类中定义的@Autowired、@Component等等注解是不会起作用的。</p><p>但是绝大多数情况下，我们既需要使用Xml配置Bean，同时也需要使用Annotation配置或组装Bean。这是怎么做到的呢？就是使用context扩展标签（除了spring-beans.xsd中定义的标签以外的所有标签都是扩展标签）：</p><blockquote><p>&lt;context:component-scan base-package=”xxx.xxx” /&gt;</p></blockquote><p>这个标签的命名空间是<a href="http://www.springframework.org/schema/context">http://www.springframework.org/schema/context</a></p><p>通过使用&lt;context:component-scan base-package=”xxx.xxx” /&gt;标签，spring会去扫描base-package指定的包下去扫描所有的Class文件，寻找潜在的Bean（被@Component标注的类），然后转换为BeanDefinition注册进BeanFactory。当使用component-scan扩展标签的时候，就默认开启了注解的解析功能，这时候，工程中所有的注解就会被spring识别并处理了（比如@Autowired、@Configuration、@Resource等）。</p><p><strong>这里一旦使用了component-scan标签，那么不管是通过Xml标签解得来的Bean还是通过component-scan扫描注解得来Bean都会开启对Spring注解（例如@Autowired）的识别（不单单是base-package中扫描得到的Bean），因为component-scan会使得BeanFactory注册一系类解析注解的BeanPostProcessor，这些BeanPostProcessor对于不管是Xml定义的Bean还是注解配置的Bean都会生效。</strong>这部分稍后会分析代码。</p><p>这样就实现了spring中Xml和注解混用。</p><h2 id="扩展标签"><a href="#扩展标签" class="headerlink" title="扩展标签"></a>扩展标签</h2><p>在context:component-scan中，context是命名空间，真正的标签是component-scan。</p><p>与component-scan相似的扩展标签还有很多，具体的作用不解释了，我们主要关心的是扩展标签是如何被spring处理的，部分扩展标签如下：</p><blockquote><p>&lt;context:annotation-config /&gt;</p><p>&lt;task:scheduled-tasks /&gt;</p><p>&lt;cache:annotation-driven mode=”aspectj”/&gt;</p><p>&lt;aop:aspectj-autoproxy /&gt;</p></blockquote><p>每个扩展标签（这里的context、task、cache、aop就是扩展标签的命名空间，”:”后面的是扩展标签）都有各自的命名空间，例如context标签的命名空间就是<a href="http://www.springframework.org/schema/context%E3%80%82">http://www.springframework.org/schema/context。</a></p><p>那么扩展标签（或者说扩展命名空间，spring中是以命名空间为单位进行处理的而不是单个的标签）在spring中是如何被处理的呢？关键就在spring.handler配置文件中。</p><h2 id="spring-handler配置文件"><a href="#spring-handler配置文件" class="headerlink" title="spring.handler配置文件"></a>spring.handler配置文件</h2><p>首先，我们关注一下Spring中的一个配置文件，spring.handler：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">http\://www.springframework.org/schema/context</span>=<span class="string">org.springframework.context.config.ContextNamespaceHandler</span></span><br><span class="line"><span class="meta">http\://www.springframework.org/schema/jee</span>=<span class="string">org.springframework.ejb.config.JeeNamespaceHandler</span></span><br><span class="line"><span class="meta">http\://www.springframework.org/schema/lang</span>=<span class="string">org.springframework.scripting.config.LangNamespaceHandler</span></span><br><span class="line"><span class="meta">http\://www.springframework.org/schema/task</span>=<span class="string">org.springframework.scheduling.config.TaskNamespaceHandler</span></span><br><span class="line"><span class="meta">http\://www.springframework.org/schema/cache</span>=<span class="string">org.springframework.cache.config.CacheNamespaceHandler</span></span><br></pre></td></tr></table></figure><p>这是一个property文件，由几组key-value组成，现在先看一下这个配置文件中的value，value比较明显都是一个全限定类名。很容易就能找到上面我们使用的context的命名空间的处理类：ContextNamespaceHandler。我们的context命名空间就是在这个类里面被处理的了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">&quot;property-placeholder&quot;</span>, <span class="keyword">new</span> PropertyPlaceholderBeanDefinitionParser());</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">&quot;property-override&quot;</span>, <span class="keyword">new</span> PropertyOverrideBeanDefinitionParser());</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">&quot;annotation-config&quot;</span>, <span class="keyword">new</span> AnnotationConfigBeanDefinitionParser());</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">&quot;component-scan&quot;</span>, <span class="keyword">new</span> ComponentScanBeanDefinitionParser());</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">&quot;load-time-weaver&quot;</span>, <span class="keyword">new</span> LoadTimeWeaverBeanDefinitionParser());</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">&quot;spring-configured&quot;</span>, <span class="keyword">new</span> SpringConfiguredBeanDefinitionParser());</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">&quot;mbean-export&quot;</span>, <span class="keyword">new</span> MBeanExportBeanDefinitionParser());</span><br><span class="line">    registerBeanDefinitionParser(<span class="string">&quot;mbean-server&quot;</span>, <span class="keyword">new</span> MBeanServerBeanDefinitionParser());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到ContextNamespaceHandler可以处理context命名空间中的如下扩展标签：</p><ul><li>property-placeholder</li><li>property-override</li><li>annotation-config</li><li>component-scan</li><li>load-time-weaver</li><li>spring-configured</li><li>mbean-export</li><li>mbean-server</li></ul><p>每个标签又有一个专门的类去解析，这里我们用上面举过的例子component-scan，看看它的处理类：ComponentScanBeanDefinitionParser。</p><h2 id="在哪里解析扩展标签"><a href="#在哪里解析扩展标签" class="headerlink" title="在哪里解析扩展标签"></a>在哪里解析扩展标签</h2><p>这里要回顾上一篇博客中的ClassPathXmlApplicationContext类了，上一节我们讲到了Xml的解析流程交给了DefaultBeanDefinitionDocumentReader去控制，这个类会遍历Xml中的每一个节点，根据节点的类型执行不同的逻辑。关键的方法在这里（类：DefaultBeanDefinitionDocumentReader.java）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultBeanDefinitionDocumentReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">      NodeList nl = root.getChildNodes();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">         Node node = nl.item(i);</span><br><span class="line">         <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">            Element ele = (Element) node;</span><br><span class="line">            <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">               parseDefaultElement(ele, delegate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               delegate.parseCustomElement(ele);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      delegate.parseCustomElement(root);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法遍历了root（代表Xml配置文件的根节点），然后遍历每一个子节点。关键方法是delegate.isDefaultNamespace这个方法，这个方法用来判断当前节点是否是beans命名空间（也是spring的Xml配置文件的默认命名空间），如果是，则继续对&lt;bean&gt;标签等进行解析，这个步骤在上篇博客详细讲过了（传送门：<a href="https://www.jelliclecat.cn/articles/Spring/spring-1.html">透Spring-1-ClassPathXmlApplicationContext</a>），如果不是，则是扩展标签，需要对扩展命名空间内的标签进行特殊处理，也就是调用delegate.parseCustomElement(ele)方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BeanDefinitionParserDelegate.java</span></span><br><span class="line"><span class="comment">// 判断当前标签是否属于默认（beans）命名空间的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BEANS_NAMESPACE_URI = <span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDefaultNamespace</span><span class="params">(<span class="meta">@Nullable</span> String namespaceUri)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (!StringUtils.hasLength(namespaceUri) || BEANS_NAMESPACE_URI.equals(namespaceUri));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了我们接着看parseCustomElement方法，同样在BeanDefinitionParserDelegate类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BeanDefinitionParserDelegate.java</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parseCustomElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBd)</span> </span>&#123;</span><br><span class="line">    String namespaceUri = getNamespaceURI(ele);</span><br><span class="line">    <span class="keyword">if</span> (namespaceUri == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    NamespaceHandler handler = <span class="keyword">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">      error(<span class="string">&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot;</span> + namespaceUri + <span class="string">&quot;]&quot;</span>, ele);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> ParserContext(<span class="keyword">this</span>.readerContext, <span class="keyword">this</span>, containingBd));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里通过节点的namespaceUri找到对应处理当前节点标签的命名空间的NamespaceHandler，然后调用parse方法去解析。</p><p>嗯~我们终于看到NamespaceHandler的身影了，还记得上面的ContextNamespaceHandler吗？快接上了，咱们继续往下看。</p><p>这里getNamespaceHandlerResolver是获取的什么类呢？获取的是接口NamespaceHandlerResolver的实现类，这个接口的实现类只有一个，就是DefaultNamespaceHandlerResolver。</p><h2 id="DefaultNamespaceHandlerResolver"><a href="#DefaultNamespaceHandlerResolver" class="headerlink" title="DefaultNamespaceHandlerResolver"></a>DefaultNamespaceHandlerResolver</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_HANDLER_MAPPINGS_LOCATION = <span class="string">&quot;META-INF/spring.handlers&quot;</span>;</span><br></pre></td></tr></table></figure><p>这是这个类上来的第一句话，是不是特别特别的亲切！（前提是你好好看了这篇博客上面的内容）</p><p>这里定义了一个字符串常量表示spring.handlers文件的位置，你是不是立马就意识到了这个类是用来干嘛的，没错，就是用来加载spring.handlers配置的，不光可以加载配置，还可以决定一个namespaceUri对应的是哪个NamespaceHandler。看看具体代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultNamespaceHandlerResolver.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> NamespaceHandler <span class="title">resolve</span><span class="params">(String namespaceUri)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; handlerMappings = getHandlerMappings();</span><br><span class="line">    Object handlerOrClassName = handlerMappings.get(namespaceUri);</span><br><span class="line">    <span class="keyword">if</span> (handlerOrClassName == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (handlerOrClassName <span class="keyword">instanceof</span> NamespaceHandler) &#123;</span><br><span class="line">      <span class="keyword">return</span> (NamespaceHandler) handlerOrClassName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      String className = (String) handlerOrClassName;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;?&gt; handlerClass = ClassUtils.forName(className, <span class="keyword">this</span>.classLoader);</span><br><span class="line">        <span class="keyword">if</span> (!NamespaceHandler.class.isAssignableFrom(handlerClass)) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(<span class="string">&quot;Class [&quot;</span> + className + <span class="string">&quot;] for namespace [&quot;</span> + namespaceUri +</span><br><span class="line">              <span class="string">&quot;] does not implement the [&quot;</span> + NamespaceHandler.class.getName() + <span class="string">&quot;] interface&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);</span><br><span class="line">        namespaceHandler.init();</span><br><span class="line">        handlerMappings.put(namespaceUri, namespaceHandler);</span><br><span class="line">        <span class="keyword">return</span> namespaceHandler;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(<span class="string">&quot;Could not find NamespaceHandler class [&quot;</span> + className +</span><br><span class="line">            <span class="string">&quot;] for namespace [&quot;</span> + namespaceUri + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (LinkageError err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FatalBeanException(<span class="string">&quot;Unresolvable class definition for NamespaceHandler class [&quot;</span> +</span><br><span class="line">            className + <span class="string">&quot;] for namespace [&quot;</span> + namespaceUri + <span class="string">&quot;]&quot;</span>, err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里的handlerMappings最初是一个字符串对字符串的map，因为最初加载的spring.handlers还是一个property文件。最后一个else里面，使用反射区拿到对应的NamespaceHandler，并保存在了handlerMappings中。这样，就加载完了spring.handlers中的所有命名空间对应的NamespaceHandler实例了。</p><p>这里是不是有点SPI的味道~</p><p>当spring扫描Xml扫描到<code>&lt;context:component-scan base-package=&quot;xxx.xxx&quot; /&gt;</code>标签时，发现不是默认命名空间，就去查找context的命名空间，就是<a href="http://www.springframework.org/schema/context%EF%BC%8C%E7%84%B6%E5%90%8E%E9%80%9A%E8%BF%87DefaultNamespaceHandlerResolver%E6%9F%A5%E6%89%BE%E8%BF%99%E4%B8%AA%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%AF%B9%E5%BA%94%E7%9A%84NamespaceHandler%EF%BC%8C%E8%BF%99%E9%87%8C%E5%B0%B1%E6%89%BE%E5%88%B0%E4%BA%86ContextNamespaceHandler%E3%80%82">http://www.springframework.org/schema/context，然后通过DefaultNamespaceHandlerResolver查找这个命名空间对应的NamespaceHandler，这里就找到了ContextNamespaceHandler。</a></p><p>接下来的解析工作就委托给了ContextNamespaceHandler，所以我们接着看ContextNamespaceHandler。</p><h2 id="ContextNamespaceHandler"><a href="#ContextNamespaceHandler" class="headerlink" title="ContextNamespaceHandler"></a>ContextNamespaceHandler</h2><p>这个类只是实现了init方法，注册进了一批标签和处理类，<code>component-scan</code>的处理类是ComponentScanBeanDefinitionParser，我们重点看看这个类，这个类实现了BeanDefinitionParser接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionParser</span> </span>&#123;</span><br><span class="line"><span class="function">BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ComponentScanBeanDefinitionParser的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ComponentScanBeanDefinitionParser.java</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE);</span><br><span class="line">    basePackage = parserContext.getReaderContext().getEnvironment().resolvePlaceholders(basePackage);</span><br><span class="line">    String[] basePackages = StringUtils.tokenizeToStringArray(basePackage,</span><br><span class="line">        ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);</span><br><span class="line"></span><br><span class="line">    ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages);</span><br><span class="line">    registerComponents(parserContext.getReaderContext(), beanDefinitions, element);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>流程非常清晰：</p><ul><li>从Element中找到base-package属性，设置待扫描包。</li><li>创建ClassPathBeanDefinitionScanner</li><li>使用ClassPathBeanDefinitionScanner扫描base-package包获得BeanDefinitions</li><li>将扫描到的BeanDefinitions注册进BeanFactory</li></ul><p>这里有个熟悉的朋友：ClassPathBeanDefinitionScanner，在这篇博客的开头讲AnnotationConfigApplicationContext的时候就提到了ClassPathBeanDefinitionScanner，里面有一个重要的方法叫doScan，用来将Class文件转换为BeanDefinition。</p><h2 id="处理注解"><a href="#处理注解" class="headerlink" title="处理注解"></a>处理注解</h2><p>这里还没完，还有一个重要的功能没有看到，就是在什么地方注册的处理注解的BeanPostProcessor。</p><p>上面parse的最后调用了registerComponents方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ComponentScanBeanDefinitionParser.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">registerComponents</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      XmlReaderContext readerContext, Set&lt;BeanDefinitionHolder&gt; beanDefinitions, Element element)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Object source = readerContext.extractSource(element);</span><br><span class="line">    CompositeComponentDefinition compositeDef = <span class="keyword">new</span> CompositeComponentDefinition(element.getTagName(), source);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder beanDefHolder : beanDefinitions) &#123;</span><br><span class="line">      compositeDef.addNestedComponent(<span class="keyword">new</span> BeanComponentDefinition(beanDefHolder));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register annotation config processors, if necessary.</span></span><br><span class="line">    <span class="keyword">boolean</span> annotationConfig = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (element.hasAttribute(ANNOTATION_CONFIG_ATTRIBUTE)) &#123;</span><br><span class="line">      annotationConfig = Boolean.valueOf(element.getAttribute(ANNOTATION_CONFIG_ATTRIBUTE));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (annotationConfig) &#123;</span><br><span class="line">      Set&lt;BeanDefinitionHolder&gt; processorDefinitions = AnnotationConfigUtils.registerAnnotationConfigProcessors(readerContext.getRegistry(), source);</span><br><span class="line">      <span class="keyword">for</span> (BeanDefinitionHolder processorDefinition : processorDefinitions) &#123;</span><br><span class="line">        compositeDef.addNestedComponent(<span class="keyword">new</span> BeanComponentDefinition(processorDefinition));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    readerContext.fireComponentRegistered(compositeDef);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>里面调用了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigUtils.registerAnnotationConfigProcessors(readerContext.getRegistry(), source);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AnnotationConfigUtils.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">registerAnnotationConfigProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      BeanDefinitionRegistry registry, <span class="meta">@Nullable</span> Object source)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);</span><br><span class="line">    <span class="keyword">if</span> (beanFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(beanFactory.getDependencyComparator() <span class="keyword">instanceof</span> AnnotationAwareOrderComparator)) &#123;</span><br><span class="line">        beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!(beanFactory.getAutowireCandidateResolver() <span class="keyword">instanceof</span> ContextAnnotationAutowireCandidateResolver)) &#123;</span><br><span class="line">        beanFactory.setAutowireCandidateResolver(<span class="keyword">new</span> ContextAnnotationAutowireCandidateResolver());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefs = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">      RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(ConfigurationClassPostProcessor.class);</span><br><span class="line">      def.setSource(source);</span><br><span class="line">      beanDefs.add(registerPostProcessor(registry, def, CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">      RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">      def.setSource(source);</span><br><span class="line">      beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.</span></span><br><span class="line">    <span class="keyword">if</span> (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">      RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line">      def.setSource(source);</span><br><span class="line">      beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.</span></span><br><span class="line">    <span class="keyword">if</span> (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">      RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,</span><br><span class="line">            AnnotationConfigUtils.class.getClassLoader()));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">            <span class="string">&quot;Cannot load optional framework class: &quot;</span> + PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      def.setSource(source);</span><br><span class="line">      beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">      RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(EventListenerMethodProcessor.class);</span><br><span class="line">      def.setSource(source);</span><br><span class="line">      beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) &#123;</span><br><span class="line">      RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(DefaultEventListenerFactory.class);</span><br><span class="line">      def.setSource(source);</span><br><span class="line">      beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> beanDefs;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>里面注册了一堆BeanPostProcessor：</p><ul><li>ConfigurationClassPostProcessor，处理@Configuration和@Bean</li><li>AutowiredAnnotationBeanPostProcessor，处理@Autowired，@Value等相关注解</li><li>CommonAnnotationBeanPostProcessor，支持JSR-250标签，@PostConstruct、@PreDestroy、@Resource</li><li>EventListenerMethodProcessor，处理@EventListener</li></ul><p>这些BeanPostProcessor就是处理各种注解的关键了。</p><p>这里也印证了上面说到的，由于注解的处理是借助BeanPostProcessor实现的，所以对所有的BeanDefinition都会生效，即使是从Xml解析过来的BeanDefinition。</p><p>要注意的是，BeanPostProcessor有很多子接口，不同的子类是在不同的生命周期中执行的，这个咱们之后会用一篇博客聊透Bean的生命周期。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;先看看AnnotationConfigApplicationContext&quot;&gt;&lt;a href=&quot;#先看看AnnotationConfigApplicationContext&quot; class=&quot;headerlink&quot; title=&quot;先看看AnnotationConfi</summary>
      
    
    
    
    <category term="Spring" scheme="https://www.jelliclecat.cn/categories/Spring/"/>
    
    
    <category term="Spring" scheme="https://www.jelliclecat.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>聊透Spring-1-ClassPathXmlApplicationContext源码解析</title>
    <link href="https://www.jelliclecat.cn/articles/Spring/spring-1/"/>
    <id>https://www.jelliclecat.cn/articles/Spring/spring-1/</id>
    <published>2019-11-13T14:41:10.000Z</published>
    <updated>2021-06-25T13:47:33.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>离上次写Spring的博客有一段时间了，之前写了三篇关于Spring的博客：</p><ul><li><a href="https://www.jelliclecat.cn/articles/Spring/spring-beans-2.html">spring-beans包源码阅读-2-BeanWrapper</a></li><li><a href="https://www.jelliclecat.cn/articles/Spring/spring-beans-3.html">spring-beans包源码阅读-3-BeanDefinition</a></li><li><a href="https://www.jelliclecat.cn/articles/Spring/spring-beans-4.html">spring-beans包源码阅读-4-BeanFactory</a></li></ul><p>从标题可以很容易看出来，主要讲了三个类BeanWrapper，BeanDefinition，BeanFactory。这三个类是spring-beans这个包里面的核心类，但是，这三篇文章在我现在看来写得不算太完整，有些理解也不算太准确。这篇博客会从ClassPathXmlApplicationContext入手，完整的走一遍Spring从xml配置文件加载Bean的过程。</p><p>Context做的事情和BeanFactory不太一样，Context是BeanFactory的超集，具有BeanFactory的所有功能。Context还提供了对Resource的访问、捕获事件等。</p><h2 id="一、入口"><a href="#一、入口" class="headerlink" title="一、入口"></a>一、入口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure><p>ClassPathXmlApplicationContext的用法入上所示，直接看构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    String[] configLocations, <span class="keyword">boolean</span> refresh, <span class="meta">@Nullable</span> ApplicationContext parent)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">super</span>(parent);</span><br><span class="line">  setConfigLocations(configLocations);</span><br><span class="line">  <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">    refresh();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终使用的是重载的构造方法，具体代码如上，关键的一步是调用refresh方法，所以接下来看看refresh接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">      <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">        postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">        registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">        initMessageSource();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">        initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">        onRefresh();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">        registerListeners();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">        finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">        finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">          logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">              <span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">        destroyBeans();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset &#x27;active&#x27; flag.</span></span><br><span class="line">        cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Propagate exception to caller.</span></span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// Reset common introspection caches in Spring&#x27;s core, since we</span></span><br><span class="line">        <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">        resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>咱们到了ClassPathXmlApplicationContext最关键的一个方法，这个方法里面包含了完整的Spring启动代码。这里先不进到具体的代码里面，先大致解释一下每个方法的作用：</p><ul><li>prepareRefresh，没干什么，设置了几个标志位标志refresh开始，不是重点。</li><li>obtainFreshBeanFactory，很关键，首先完成了读取Xml并将配置翻译为BeanDefinition，创建了一个DefaultListableBeanFactory作为Context的BeanFactory。DefaultListableBeanFactory前面的博客中讲到过，是BeanFactory的默认实现，也是BeanFactory功能的集大成者。最后将翻译过后的BeanDefinition全部注册进BeanFactory，等待初始化。</li><li>prepareBeanFactory，对BeanFactory做了一些基本的设置，设置了一些默认的Bean，比如ApplicationContext，这也是为什么我们我们可以直接通过@Autowired去获取一个ApplicationContext的原因。</li><li>postProcessBeanFactory，一个钩子方法，或者说模板方法，留给子类实现。</li><li>invokeBeanFactoryPostProcessors，调用所有的BeanFactoryPostProcessor，这步会借助BeanFactory的getBean去获取BeanFactoryPostProcessor类型的Bean。</li><li>registerBeanPostProcessors，找出所有的BeanPostProcessor，然后注册进BeanFactory，等待会实例化和初始化Bean的时候使用。</li><li>initMessageSource，初始化国际化资源。</li><li>initApplicationEventMulticaster，初始化事件分发器。</li><li>onRefresh，也是一个模板方法。</li><li>registerListeners，找到时间监听的Bean，并注册。</li><li>finishBeanFactoryInitialization，重要的一个方法，里面触发了对所有Bean的初始化。</li><li>finishRefresh，结束了Context的refresh，修改一些标志位和发送刷新完成的事件。</li></ul><p>接下来我们一个一个跟进这些方法，国际化、事件相关的不是本篇博客的重点。</p><h2 id="二、obtainFreshBeanFactory方法"><a href="#二、obtainFreshBeanFactory方法" class="headerlink" title="二、obtainFreshBeanFactory方法"></a>二、obtainFreshBeanFactory方法</h2><p>这个方法创建了BeanFactory，并将Xml配置中配置的Bean转换成了BeanDefinition。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  AbstractRefreshableApplicationContext.java</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">      destroyBeans();</span><br><span class="line">      closeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">      beanFactory.setSerializationId(getId());</span><br><span class="line">      customizeBeanFactory(beanFactory);</span><br><span class="line">      loadBeanDefinitions(beanFactory);</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>跟两次就能来到这个方法，这个方法会先试图销毁已经存在的BeanFactory，然后会创建一个DefaultListableBeanFactory（可以参考<a href="https://www.jelliclecat.cn/articles/Spring/spring-beans-4.html">spring-beans包源码阅读-4-BeanFactory</a>）。最后调用了一个loadBeanDefinitions，这步就是从Xml配置中加载BeanDefinition了，我们稍微进去看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractXmlApplicationContext.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">  <span class="comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span></span><br><span class="line">  XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Configure the bean definition reader with this context&#x27;s</span></span><br><span class="line">  <span class="comment">// resource loading environment.</span></span><br><span class="line">  beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">  beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">  beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line">  <span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line">  initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">  loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到创建了一个XmlBeanDefinitionReader去解析Xml，继续进入loadBeanDefinitions方法，最终可以走到XmlBeanDefinitionReader的doLoadBeanDefinition方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">    <span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先使用doLoadDocument将Xml文件通过w3c.doc工具解析成Document，这部分就不赘述了，继续看registerBeanDefinitions：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XmlBeanDefinitionReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">  BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">  <span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">  documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">  <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重要的方法是registerBeanDefinitions，这个方法在BeanDefinitionDocumentReader这个类中，这个类是专门负责将Document转换成BeanDefinition的类，进去看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultBeanDefinitionDocumentReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Any nested &lt;beans&gt; elements will cause recursion in this method. In</span></span><br><span class="line">  <span class="comment">// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span></span><br><span class="line">  <span class="comment">// keep track of the current (parent) delegate, which may be null. Create</span></span><br><span class="line">  <span class="comment">// the new (child) delegate with a reference to the parent for fallback purposes,</span></span><br><span class="line">  <span class="comment">// then ultimately reset this.delegate back to its original (parent) reference.</span></span><br><span class="line">  <span class="comment">// this behavior emulates a stack of delegates without actually necessitating one.</span></span><br><span class="line">  BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">  <span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">    String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">      String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">          profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">      <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">          logger.info(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">              <span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  preProcessXml(root);</span><br><span class="line">  parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">  postProcessXml(root);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的方法落在这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">preProcessXml(root);</span><br><span class="line">parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">postProcessXml(root);</span><br></pre></td></tr></table></figure><p>preProcessXml和postProcessXml也是两个模板方法，留给子类一个扩展的入口，核心方法是parseBeanDefinitions，最后会走到parseDefaultElement方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">    importBeanDefinitionResource(ele);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">    processAliasRegistration(ele);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">    processBeanDefinition(ele, delegate);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">    <span class="comment">// recurse</span></span><br><span class="line">    doRegisterBeanDefinitions(ele);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法里面可以看到解析Xml的骨干方法了：</p><ul><li>importBeanDefinitionResource，首先检查Xml有没有import其他的Xml配置文件，如果有，则递归解析import标签所引用的配置文件。</li><li>processAliasRegistration，解析alias标签。</li><li>processBeanDefinition，核心方法，将&lt;bean&gt;标签解析成一个BeanDefinition。</li><li>doRegisterBeanDefinitions，递归解析嵌套的&lt;beans&gt;标签。</li></ul><p>所以我们只用看processBeanDefinition就可以了，最终会走到BeanDefinitionParserDelegate这个类中，这个类是更加具体的解析一个BeanDefinition的委托类，不要和刚刚的BeanDefinitionDocumentReader混淆，BeanDefinitionDocumentReader负责整体的解析流程的控制，没有涉及解析的细节，解析每个具体的BeanDefinition的任务是交给BeanDefinitionParserDelegate实现的。BeanDefinitionParserDelegate里面可以看到完整的将Xml标签转换为Definition的过程，核心方法是parseBeanDefinitionElement：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BeanDefinitionParserDelegate.java</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">parseBeanDefinitionElement</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Element ele, String beanName, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> BeanEntry(beanName));</span><br><span class="line"></span><br><span class="line">  String className = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">    className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">  &#125;</span><br><span class="line">  String parent = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">    parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line"></span><br><span class="line">    parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">    bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line"></span><br><span class="line">    parseMetaElements(ele, bd);</span><br><span class="line">    parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">    parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line"></span><br><span class="line">    parseConstructorArgElements(ele, bd);</span><br><span class="line">    parsePropertyElements(ele, bd);</span><br><span class="line">    parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">    bd.setResource(<span class="keyword">this</span>.readerContext.getResource());</span><br><span class="line">    bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bd;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">    error(<span class="string">&quot;Bean class [&quot;</span> + className + <span class="string">&quot;] not found&quot;</span>, ele, ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (NoClassDefFoundError err) &#123;</span><br><span class="line">    error(<span class="string">&quot;Class that bean class [&quot;</span> + className + <span class="string">&quot;] depends on not found&quot;</span>, ele, err);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    error(<span class="string">&quot;Unexpected failure during bean definition parsing&quot;</span>, ele, ex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里其实就比较简单了，首先拿到Xml标签中的class属性的值，然后就可以去拿到对应的Class创建BeanDefinition了，然后后面继续解析Xml的节点，将配置都保存在BeanDefinition中。</p><p>最后我们回到DefaultBeanDefinitionDocumentReader中的processBeanDefinition方法中，可以看到在我们获得具体BeanDefinition之后，调用registerBeanDefinition方法将BeanDefinition和classname注册进了我们的BeanFactory中，这部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultBeanDefinitionDocumentReader.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">  BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">  <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">    bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">      BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">      getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">          bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Send registration event.</span></span><br><span class="line">    getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BeanDefinitionReaderUtils.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register bean definition under primary name.</span></span><br><span class="line">  String beanName = definitionHolder.getBeanName();</span><br><span class="line">  registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register aliases for bean name, if any.</span></span><br><span class="line">  String[] aliases = definitionHolder.getAliases();</span><br><span class="line">  <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">      registry.registerAlias(beanName, alias);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体解析每个标签的过程就不追究细节了。</p><p><em>这部分代码在《Spring源码深度解析》这本书里面有详细介绍。</em></p><h2 id="三、invokeBeanFactoryPostProcessors方法"><a href="#三、invokeBeanFactoryPostProcessors方法" class="headerlink" title="三、invokeBeanFactoryPostProcessors方法"></a>三、invokeBeanFactoryPostProcessors方法</h2><p>BeanFactoryPostProcessor的作用，是给用户在BeanDefinition被创建为一个个Bean实例之前做一些自定义行为的扩展接口，这个接口在一些和Spring对接的框架里面非常有用，比如我们的框架中可以自定义了各种各样的Bean，最终需要Spring帮我们去创建和管理这些Bean，那么我们可以写一个自定义的BeanFactoryPostProcessor，然后里面将我们的各种类转换为BeanDefinition，最后注册进BeanFactory，在之后BeanFactory创建Bean的时候，就会把我们自定义的BeanDefinition也创建成一个一个的Bean了。当然我们也可以通过这个接口去修改已经存在的BeanDefinition。</p><p>invokeBeanFactoryPostProcessors这个方法最终委托给了PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors方法，这个方法非常的长，但是其实很有调理，主要是通过检查我们的BeanFactory和BeanFactoryPostProcessor不同的子类，并通过不同优先级去执行所有的BeanFactoryPostProcessor。</p><p>这里有个问题，获取BeanFactoryPostProcessor是通过BeanFactory#getBean的方法获取的，这意味着如果在BeanFactoryPostProcessor中引用了其他的Bean，就会引起这些Bean提前被创建，那么某些BeanFactoryPostProcessor和BeanPostProcessor的自定义修改就不会对这些Bean生效了，这块需要特别注意，不然会引发一些奇怪的Bug。</p><p>这部分代码就不跟踪了，因为调用栈很浅，最终代码全部都在PostProcessorRegistrationDelegate这个类里面，大家自行查看吧。</p><h2 id="四、registerBeanPostProcessors方法"><a href="#四、registerBeanPostProcessors方法" class="headerlink" title="四、registerBeanPostProcessors方法"></a>四、registerBeanPostProcessors方法</h2><p>BeanPostProcessors和BeanFactoryPostProcessor的作用不同，BeanPostProcessors作用在Bean的实例化、初始化的过程中。BeanPostProcessors有很多不同的扩展子类，用于创建Bean的不同生命周期中。</p><p>这里的registerBeanPostProcessors方法和invokeBeanFactoryPostProcessors方法非常类似，代码也在PostProcessorRegistrationDelegate中，只不过这里只是将所有的BeanPostProcessors通过BeanFactory#getBean找出来，然后注册进了BeanFactory中。</p><p>具体的细节也不展开了，这里的逻辑比较简单，同时要注意被BeanPostProcessors引用的Bean会提前暴露的问题。</p><h2 id="五、finishBeanFactoryInitialization方法"><a href="#五、finishBeanFactoryInitialization方法" class="headerlink" title="五、finishBeanFactoryInitialization方法"></a>五、finishBeanFactoryInitialization方法</h2><p>最后看看这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractApplicationContext.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line">  <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">      beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">    beanFactory.setConversionService(</span><br><span class="line">        beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">  <span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">  <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">  <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">    beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">  String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">  <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">    getBean(weaverAwareName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">  beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">  beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">  beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最关键的是最后一行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.preInstantiateSingletons();</span><br></pre></td></tr></table></figure><p>这里加载了Spring中所有的Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultListableBeanFactory.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">    <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">    List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">      <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">          Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">          <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">            <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">            <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">              isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">                      ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">                  getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                  ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">              getBean(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          getBean(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">      Object singletonInstance = getSingleton(beanName);</span><br><span class="line">      <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">        <span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">          AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">            smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          &#125;, getAccessControlContext());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里挨个初始化了所有的Bean，也比较好懂。</p><p>当调用了getBean之后，后面的逻辑就可以参考<a href="https://www.jelliclecat.cn/articles/Spring/spring-beans-4.html">spring-beans包源码阅读-4-BeanFactory</a>这篇博客了。</p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>ClassPathXmlApplicationContext的代码还是挺简单的，这个Context负责的是纯Xml配置的Spring加载方式，之后我们会讲AnnotationConfigApplicationContext，这个Context支持的是注解配置类型的加载方式，以及会讲Xml和注解是如何混合使用的。</p><p>在讲AnnotationConfigApplicationContext之前，还会使用一篇博客回顾一下BeanFactory初始化Bean的过程。</p><p>这里有一篇宏观讲解Spring的博客，是我见过的所有写Spring博客里面最好的一篇，推荐给大家：</p><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-spring-principle/index.html">Spring 框架的设计理念与设计模式分析</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;离上次写Spring的博客有一段时间了，之前写了三篇关于Spring的博客：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://w</summary>
      
    
    
    
    <category term="Spring" scheme="https://www.jelliclecat.cn/categories/Spring/"/>
    
    
    <category term="Spring" scheme="https://www.jelliclecat.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>6.1-11.11小结</title>
    <link href="https://www.jelliclecat.cn/articles/Summary/summary-20191112/"/>
    <id>https://www.jelliclecat.cn/articles/Summary/summary-20191112/</id>
    <published>2019-11-12T00:02:10.000Z</published>
    <updated>2021-06-25T13:47:33.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="6-1-11-11小结"><a href="#6-1-11-11小结" class="headerlink" title="6.1-11.11小结"></a>6.1-11.11小结</h2><p>上次总结的时间是6月1号，到今天已经过去了五个半月，在这过去的五个半月里面，我对自己的学习进度还是比较满意的。</p><p>六月份，我参加了第五届中间件性能挑战赛，这对我来说是一个全新的开始。初赛的内容是基于dubbo框架设计一个动态负载均衡算法，使得系统的综合吞吐量达到最大，我的思路是在加权随机的基础上，根据服务器的实时负载计算权重，使得负载最为合理。考虑使用加权随机是因为随机加权不需要加锁，而加权轮询是需要加锁的，后来想想这也许是一个错误的决定，因为在所有provider几乎满载的情况下，随机带来的扰动是非常致命的。在主体思路确定之后，整个算法面临着两个挑战：一，如何获取服务器的实时负载，并让Gateway实时知晓每个服务器的负载；二，如何根据负载调整权重。框架提供了一个callback方法，用于让provider给Gateway回传信息，这样，服务器可以自行计算自己的负载，然后通过callback回传给Gateway，这样Gateway就知晓了每个provider的负载。但是这样明显是不合理的，因为一个callback的RPC调用将会有数毫秒的延迟，在高并发下，数毫秒的延迟意味着Gateway在这段时间里面使用的是没有调整的权重，轻则导致整体性能下降，重则导致服务器负载发生震荡，甚至宕机。解决办法是使用Gateway去记录每个provider的负载，这样可以做到实时性，但是会轻微加重Gateway的负载（记录负载必须加锁）。另一种更好的做法是使用CompletableFuture，这样可以实现反应式流回压。再就是如何根据负载信息调整权重了，我采用的方式也比较简单，根据服务器的平均响应时间和空闲线程数综合考虑，平均响应时间使用的是时间窗平均值的做法，削弱服务器响应时间的波动。如果服务器略微超载，那么多余的请求会排队，由于排队对于提升系统吞吐量没有任何的帮助，所以我们需要尽量避免排队。这时有一个非常棒的算法叫做“拥塞探测法”，指的是在高并发下，如果有请求在某个时间内返回，那么可以断言该服务器没有拥塞（或者说排队），这样，我们就可以适当提高该服务器的权重，同理，如果某个服务器在一段时间内没有任何请求可以在一个规定的时间内返回，那么可以认定该服务器发生了拥塞，那么可以对其进行适当的降权。最终初赛的成绩是34名（4000+队伍）。复赛由于主办方在最后十天换了题目并且清空了排行榜，而我在那段时间又特别忙，所以没有走到最后，改题之前到了30多名。复赛的内容是做一个类似TSDB的存储引擎，具有范围查、范围聚合的能力，能够在规定时间内写入100G的数据，具体思路不展开了。</p><p>不得不说中间件比赛真是有意思，见识了很多大佬，也有机会认识一些大佬，和大佬们交流交流心得，学习到了很多，也意识到自己的路还有很长很长。</p><p>中间件比赛之后，我对dubbo以及中间件框架产生了浓厚的兴趣，这段时间，基本上都在dubbo、motan、netty这三个框架的源码中遨游。不得不说，读源码真是一件会让人上瘾的事情，每天不读一下就是难受。由于自己有着浓厚的兴趣，netty的核心代码（Channel、Pipeline、ChannelHandler、ByteBuf、Codec、Bootstrap）已经熟读于心了，核心原理自然是完全掌握。netty的内存管理也是一绝，这部分还没看到，之后会继续将整个框架看完。motan是dubbo的缩小版，代码量不多，极其适合作为RPC的入门读物，motan的整个框架我也看完了。之后就是dubbo，看motan之前，觉得dubbo充满了炫技，有点点华而不实的感觉。在看motan的过程中将两个框架来回比较，每一个motan的实现我都会去看看dubbo是怎么实现的，最后看完motan之后，才觉得dubbo的代码是那么的好。dubbo我还没有完全看完，不过主体框架以及编程思路可以算是略知一二了。看完这几个框架之后，我有点手痒痒，就自己尝试写了一个RPC框架，在自己写框架的时候，才发现自己的很多不足，比如异常的设计，如何增强代码健壮性等等问题，都足以让我头疼，不过我就是邯郸学步，一点一点来吧。</p><p>最近好好研究了一下异步RPC框架怎么实现。motan的做法是对业务方的服务接口自己扩展一个接口，这个接口是motan自己使用JavaPoet动态生成的，用以对每个同步的业务方法扩展出一个对应的异步方法。实际上业务方会得到两个接口，异步接口使用的接口是motan生成的接口而不是自己定义的业务接口。这样做怎么说呢，也算是一种实现吧，有一点不好的是motan扩展出的异步方法返回的是一个AsyncResponse，这是RPC框架内部的一个类。我觉得更好的方法是返回一个CompletableFuture，这样RPC内部的类没有侵入到业务方法中去。还有一点不好的是这里框架自动生成了一个接口，如果对这点不了的会有一些框架学习成本，没有做到完全的RPC过程透明。dubbo提供了N种异步调用的方式<a href="http://dubbo.apache.org/zh-cn/blog/dubbo-new-async.html">dubbo全链路异步调用</a>，在我看来只有第一种是合理的做法，其他的做法都会对业务方造成框架侵入，第一种做法也和我自己实现的异步调用的方法不谋而合。我自己实现了一版异步RPC调用，原理是RPC框架检查业务方方法返回的类型是否是一个CompletableFuture，如果是，则判断该方法是异步方法。这样做其实非常的合理，因为如果业务方定义的返回类型是CompletableFuture，那毫无疑问这个方法将会是一个异步方法，这样，业务方的服务实现照常的实现，不会感觉到RPC的存在，也就是没有任何的侵入，然后RPC在业务方返回的CompletableFuture中的whenComplete方法中注册一条回调函数链，这个链一端连着业务方的实现（RPC的Server端），一端连着调用方（RPC的Client端），中间跨越了网络，当业务方complete的时候，就会沿着回调链一直触发到Client端。这样，无论是在调用方还是实现方，都感觉不到RPC框架的存在，实现了零侵入，这种模式也是一种反应式设计模式。<a href="https://github.com/zhengrenjie/drpc">实现连接</a></p><p>最近回头再看Spring的源码，之前写了几篇Spring的博客，但其实没有写的很详细，最近回头再看Spring的源码的时候才觉得，温故而知新。Spring的源码看的非常舒服，除了使用非人类的“\t”作为代码缩进之外。我看源码的时候多了很多的思考，比如看到Spring执行PostBeanProcessor的时候，我不禁会想，如果在PostBeanProcessor中引用了其他的Bean，是不是会导致这部分被引用的Bean提前被加载，从而享受不到后面的PostBeanProcessor的服务呢？答案还真是这样，这里通过看源码发现了一个大坑，如果这里没注意的话，极可能发生一些难以排查的Bug。还有，Xml加载Bean很容易理解，只用根据Xml中定义的class字段使用ClassLoader去加载就行了，但是Annotation的Scan加载Bean怎么办？如果使用ClassLoader去加载每个Class文件的话，开销大不说，如果不小心触发了一些Class的static域怎么办，那样肯定会出一些奇怪的Bug。那到底要怎么样既不去加载Class，又可以获取Class的元信息呢？抱着这个疑问去看源码，发现果然，Spring直接将class的ASM字节码作为byte[]读出来，然后去解析class的字节码找每个class的原信息。不看不知道，一看吓一跳啊，之前从来没有在其他博客里面见有人提到这个问题。</p><p>博客有段时间没有更新了，主要是我这个人，非得到自己看源码看到满足才会愿意花时间写博客，看源码在学习新知识的同时，也会抛出各种新的东西需要去理解和学习，所以一般来说会等到把一个框架的主要代码都看得差不多了才会想起来写博客。接下来应该是写一些Spring的源码以及Dubbo的源码解读吧，这段时间回头看了Spring的Context部分，之后会继续看一下SpringMVC和WebFlux的部分，Spring对反应式的支持还是非常吸引我的。之前想了继续完善一下Netty的源码博客，比如编解码部分、ByteBuf部分，但是想了想，这部分代码没有Channel内容多，也没有transport包下的代码有意思，所以还是先搁置吧。Dubbo的话，应该说还没有仔细深入的看，motan源码倒是看完了，motan可以用1-2篇博客简单介绍一下，因为代码量确实不多，实现也没有dubbo那么复杂。</p><p>接下来学习的话，Spring再巩固巩固吧，paxos确实很迷人，尝试了几次也没有完整的理解下来，距离2020年还有1个半月，这一个半月尽量将raft算法彻底掌握吧。当然不止这一个算法，Dubbo和Zookeeper可以继续深入一下。之前看了Tomcat的部分源码，只看了很少的一部分，HTTP协议解析的那一部分，结合《How Tomcat Works》这本书一起看的，这本书真的很不错，手把手教你写一个Tomcat，但是里面代码比较老了，是基于Tomcat4写的，所以里面有很多代码需要自己重新写一遍（作者也不是全部代码都是自己写的，有一些类直接copy的tomcat4源码），这儿部分暂时没有时间去做了，接下来看时间吧，攒的源码有点过于多了，看不过来，只能一个一个来，路漫漫其修远。</p><p>双11买了四本书：《反应式设计模式》、《Hbase原理与实现》、《Hadoop权威指南》、《k8s权威指南》，接下来应该好好看看Hadoop家族和微服务了（明年吧），还有Linux的一些底层原理。</p><p>之前找到了Linux0.1.1版的源码，据说这是Linux能找到的最早的一个版本，用我大学的C语言基础尝试着看了一部分，可把我牛逼坏了，哎哟叉会腰。目前还没有看出什么名堂，C语言还需要系统的学习才行，看源码是需要一定基础的。</p><p>在知乎上经常看到不建议阅读源码的论调，说“代码本来就不是给人读的”，“读源码是效率极低的学习方法”等等。我强烈反对这种观点。不得不说，看源码的门槛非常高，至少比普通的开发工作难很多（业务开发，不是开发框架），需要有扎实的语言基础和英语基础，还需要有对框架正确的理解，以及一些阅读源码甚至开发框架的经验。但是一旦读顺了之后，就会发现所有的其他学习方法都不如静下心来debug一遍源码。debug源码耗费的时间并没有想象中那么长，只不过源码极其枯燥并且抽象，所以这个过程很少有人能坚持下来，但是如果能坚持下来，会发现这样做比看书要好得多，书本上的生涩语言并不如源码来得直接，特别是从英文翻译过来的书籍。拿《Netty In Action》举例，我手上的是中文版的，很多翻译晦涩难懂，很难将那些翻译后的中文名词和源码中原本的内容相对应起来，把本来就很难懂的代码徒增了不少理解成本，而《Spring In Action》我看的是英文原版，只能说你看过一次英文版的就再也回不去了。当然，书也是必不可少的，书本最有用的部分在于目录部分，因为目录是对一个知识体系很好的归纳，可以根据目录去查漏补缺，毕竟看源码很难有这种宏观的体系感，对于你感兴趣的章节，也可以静下心来阅读以下，也许能发现不一样的视角和知识盲点。总的来说，优秀的源码是programmer最好的教材，其次是优秀的英文书籍，再其次是中文书籍，最次的是视屏，我觉得视屏知识密度太低。</p><p>加油吧，作为一个Java小菜鸡~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;6-1-11-11小结&quot;&gt;&lt;a href=&quot;#6-1-11-11小结&quot; class=&quot;headerlink&quot; title=&quot;6.1-11.11小结&quot;&gt;&lt;/a&gt;6.1-11.11小结&lt;/h2&gt;&lt;p&gt;上次总结的时间是6月1号，到今天已经过去了五个半月，在这过去的五个半</summary>
      
    
    
    
    <category term="Summary" scheme="https://www.jelliclecat.cn/categories/Summary/"/>
    
    
    <category term="Summary" scheme="https://www.jelliclecat.cn/tags/Summary/"/>
    
  </entry>
  
  <entry>
    <title>Netty源码-5-Accept和Read事件监听过程</title>
    <link href="https://www.jelliclecat.cn/articles/Netty/netty-5/"/>
    <id>https://www.jelliclecat.cn/articles/Netty/netty-5/</id>
    <published>2019-09-21T11:32:03.000Z</published>
    <updated>2021-06-25T13:47:33.056Z</updated>
    
    <content type="html"><![CDATA[<p>前面我们仔细分析过NioEventLoop的源码，以及找到了Netty事件驱动的源头代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();</span><br><span class="line">        <span class="keyword">if</span> (!k.isValid()) &#123;</span><br><span class="line">            <span class="keyword">final</span> EventLoop eventLoop;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                eventLoop = ch.eventLoop();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignored) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (eventLoop != <span class="keyword">this</span> || eventLoop == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            unsafe.close(unsafe.voidPromise());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> readyOps = k.readyOps();</span><br><span class="line">            <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> ops = k.interestOps();</span><br><span class="line">                ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">                k.interestOps(ops);</span><br><span class="line"></span><br><span class="line">                unsafe.finishConnect();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">                ch.unsafe().forceFlush();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">                unsafe.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException ignored) &#123;</span><br><span class="line">            unsafe.close(unsafe.voidPromise());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>讲NioEventLoop的时候，后面就没有接着讲事件被触发之后的操作了，我们当时只知道了，这里是Nio事件触发的源头，是监听事件的地方。</p><p>这篇博客我们来看一看，当SelectionKey.OP_READ | SelectionKey.OP_ACCEPT这两个事件被Netty监听到之后，Netty会怎么操作。</p><p>先看看SelectionKey.OP_ACCEPT。看到这篇文章应该知道了，Server端的是有两个层次的：boss和worker，boss用来接收ACCEPT事件，worker用来持有建立的连接以及继续监听连接的读写事件。</p><p>所以这里SelectionKey.OP_ACCEPT事件触发后，最后一定会创建一个连接，并交给worker线程池。下面我们分析源码：</p><h2 id="ServerBootstrapAcceptor"><a href="#ServerBootstrapAcceptor" class="headerlink" title="ServerBootstrapAcceptor"></a>ServerBootstrapAcceptor</h2><p>先必须要回忆一下ServerBootstrapAcceptor，这个类是一个ChannelHanlder，是boss Channel创建的时候注册到pipeline中去的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServerBootstrap#init()方法，截取一部分</span></span><br><span class="line">p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                        ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最后调用pipeline.addLast，将一个ServerBootstrapAcceptor实例注册进了pipeline。</p><p>ServerBootstrapAcceptor.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerBootstrapAcceptor</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Channel child = (Channel) msg;</span><br><span class="line"></span><br><span class="line">        child.pipeline().addLast(childHandler);</span><br><span class="line"></span><br><span class="line">        setChannelOptions(child, childOptions, logger);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;</span><br><span class="line">            child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                        forceClose(child, future.cause());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            forceClose(child, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类主要实现了channelRead方法，这个方法会被pipeline#fireChannelRead方法回调。也就是说，read事件链被触发的时候，这个方法会被回调，这里记一下这个方法被触发的地方。</p><p>先看一下这个channelRead方法干了什么，首先传进来的参数msg被强制转换为Channel类型，这个应该是在调用方保证的，可以猜想到这个Channel是刚刚Client和Server建立的连接。接下来调用<code>child.pipeline().addLast(childHandler)</code>往子Channel的pipeline中注册一个事件处理类：childHandler，这个类是在调用ServerBootstrap#childHandler的时候设置进来的。最后将Channel注册进childGroup，这个childGroup是一个NioEventLoopGroup，也就是worker线程池。</p><p>这里验证了我们的猜想，总结一下：</p><p>初始化NioServerSocketChannel（init方法）的时候，在NioServerSocketChannel的pipeline中注册了一个ServerBootstrapAcceptor，当这个类的channelRead方法被回调时，建立的连接，也就是一个新的Channel被注册到worker线程组中。</p><p>这就是NioServerSocketChannel负责的功能啦。</p><p>好了，大致流程已经分析清楚了，接下来仔仔细细的看一下整个流程：</p><h2 id="SelectionKey-OP-ACCEPT事件"><a href="#SelectionKey-OP-ACCEPT事件" class="headerlink" title="SelectionKey.OP_ACCEPT事件"></a>SelectionKey.OP_ACCEPT事件</h2><p>这个事件被触发的时候，调用了unsafe.read()，这个unsafe就是NioServerSocketChannel对应的unsafe，调用的unsafe#read方法实际是调用NioServerSocketChannel的父类AbstractNioMessageChannel中的内部类NioMessageUnsafe#read方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NioMessageUnsafe</span> <span class="keyword">extends</span> <span class="title">AbstractNioUnsafe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; readBuf = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">eventLoop</span><span class="params">()</span>.<span class="title">inEventLoop</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">        <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line">        <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();</span><br><span class="line">        allocHandle.reset(config);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line">        Throwable exception = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> localRead = doReadMessages(readBuf);</span><br><span class="line">                    <span class="keyword">if</span> (localRead == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (localRead &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        closed = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    allocHandle.incMessagesRead(localRead);</span><br><span class="line">                &#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                exception = t;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> size = readBuf.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">                readPending = <span class="keyword">false</span>;</span><br><span class="line">                pipeline.fireChannelRead(readBuf.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">            readBuf.clear();</span><br><span class="line">            allocHandle.readComplete();</span><br><span class="line">            pipeline.fireChannelReadComplete();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">                closed = closeOnReadError(exception);</span><br><span class="line"></span><br><span class="line">                pipeline.fireExceptionCaught(exception);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">                inputShutdown = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (isOpen()) &#123;</span><br><span class="line">                    close(voidPromise());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">                removeReadOp();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面干了两件事：</p><ul><li>doReadMessages(readBuf)</li><li>pipeline.fireChannelRead(readBuf.get(i))</li></ul><p>惯例一个个看：</p><h3 id="1-doReadMessages"><a href="#1-doReadMessages" class="headerlink" title="1. doReadMessages"></a>1. doReadMessages</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadMessages</span><span class="params">(List&lt;Object&gt; buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    SocketChannel ch = SocketUtils.accept(javaChannel());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch != <span class="keyword">null</span>) &#123;</span><br><span class="line">            buf.add(<span class="keyword">new</span> NioSocketChannel(<span class="keyword">this</span>, ch));</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;Failed to create a new channel from an accepted socket.&quot;</span>, t);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ch.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t2) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;Failed to close a socket.&quot;</span>, t2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法在子类NioServerSocketChannel中，很简单的调用了SocketUtils.accept(javaChannel())，其实就是调用JDK原生的accept方法，接纳一个新的客户端，并返回一个客户端的句柄SocketChannel，然后包装成Netty中的NioSocketChannel类，add到buf中。</p><p>当这个方法返回之后，List&lt;Object&gt; buf中被填充了所有刚刚Accept的Client端的连接。</p><h3 id="2-pipeline-fireChannelRead-readBuf-get-i"><a href="#2-pipeline-fireChannelRead-readBuf-get-i" class="headerlink" title="2. pipeline.fireChannelRead(readBuf.get(i))"></a>2. pipeline.fireChannelRead(readBuf.get(i))</h3><p>这个方法在一个for循环中，挨个触发channelRead事件链。这里的pipeline是NioServerSocketChannel这个类的pipeline，所以最终会调用ServerBootstrapAcceptor的channelRead方法，传入的参数是NioSocketChannel实例。</p><p>这里调用完后，后面的逻辑上面已经讲过了，ServerBootstrapAcceptor将这个客户端连接实例注册到了worker线程组中，开始监听并处理之后的读写事件。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这里比较容易疑惑的是，SelectionKey.OP_READ | SelectionKey.OP_ACCEPT这两个事件被同时监听，并都触发的是unsafe.read()事件，但是，如果调用了NioServerSocketChannel的pipeline的channelRead事件链的话，可以保证一定是SelectionKey.OP_ACCEPT事件，因为NioServerSocketChannel监听的只有OP_ACCEPT事件，所以NioServerSocketChannel绑定的EventLoop中触发出来的事件只可能是SelectionKey.OP_ACCEPT事件被触发。</p><h2 id="趁热打铁看看Read事件"><a href="#趁热打铁看看Read事件" class="headerlink" title="趁热打铁看看Read事件"></a>趁热打铁看看Read事件</h2><p>Read事件由刚刚accept之后，new出来的NioSocketChannel来负责监听。看看这个类的创建：</p><p>NioSocketChannel.java构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioSocketChannel</span><span class="params">(Channel parent, SocketChannel socket)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>(parent, socket);</span><br><span class="line">     config = <span class="keyword">new</span> NioSocketChannelConfig(<span class="keyword">this</span>, socket.socket());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>调用了父类AbstractNioByteChannel的构造函数，<strong>注意：NioSocketChannel.java的父类是AbstractNioByteChannel，NioServerSocketChannel的父类是AbstractNioMessageChannel，这两个父类是不一样的，名字很相似</strong>。</p><p>【BTW】NioServerSocketChannel和NioSocketChannel两个句柄前面是服务端的，后面是客户端的，和JDK命名规则一样。</p><p>看AbstractNioByteChannel的构造：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioByteChannel</span><span class="params">(Channel parent, SelectableChannel ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent, ch, SelectionKey.OP_READ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了这里得到了一个重要的信息，NioSocketChannel监听的是OP_READ事件。剩下两个参数很好理解，parent就是NioServerSocketChannel实例，ch是Accept事件被处理之后，创建的java原生的SelectableChannel。</p><p>所以当监听到OP_READ事件之后，会调用<code>unsafe.read()</code>，这里的unsafe是在AbstractNioByteChannel中实现的unsafe，看看它的NioByteUnsafe#read方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ChannelConfig config = config();</span><br><span class="line">    <span class="keyword">if</span> (shouldBreakReadReady(config)) &#123;</span><br><span class="line">        clearReadPending();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> ChannelPipeline pipeline = pipeline();</span><br><span class="line">    <span class="keyword">final</span> ByteBufAllocator allocator = config.getAllocator();</span><br><span class="line">    <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();</span><br><span class="line">    allocHandle.reset(config);</span><br><span class="line"></span><br><span class="line">    ByteBuf byteBuf = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> close = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            byteBuf = allocHandle.allocate(allocator);</span><br><span class="line">            allocHandle.lastBytesRead(doReadBytes(byteBuf));</span><br><span class="line">            <span class="keyword">if</span> (allocHandle.lastBytesRead() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                byteBuf.release();</span><br><span class="line">                byteBuf = <span class="keyword">null</span>;</span><br><span class="line">                close = allocHandle.lastBytesRead() &lt; <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (close) &#123;</span><br><span class="line">                    readPending = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            allocHandle.incMessagesRead(<span class="number">1</span>);</span><br><span class="line">            readPending = <span class="keyword">false</span>;</span><br><span class="line">            pipeline.fireChannelRead(byteBuf);</span><br><span class="line">            byteBuf = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line"></span><br><span class="line">        allocHandle.readComplete();</span><br><span class="line">        pipeline.fireChannelReadComplete();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (close) &#123;</span><br><span class="line">            closeOnRead(pipeline);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        handleReadException(pipeline, byteBuf, t, close, allocHandle);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">            removeReadOp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应于NioMessageUnsafe的read方法，这里同样干了两个重要的事情：</p><ul><li>doReadBytes</li><li>fireChannelRead</li></ul><h3 id="doReadBytes"><a href="#doReadBytes" class="headerlink" title="doReadBytes"></a>doReadBytes</h3><p>这个方法是一个模板方法，在NioSocketChannel中实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadBytes</span><span class="params">(ByteBuf byteBuf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();</span><br><span class="line">    allocHandle.attemptedBytesRead(byteBuf.writableBytes());</span><br><span class="line">    <span class="keyword">return</span> byteBuf.writeBytes(javaChannel(), allocHandle.attemptedBytesRead());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里其实就是将javaChannel中的数据读到了ByteBuf中，然后返回了，具体过程不再分析。</p><h3 id="fireChannelRead"><a href="#fireChannelRead" class="headerlink" title="fireChannelRead"></a>fireChannelRead</h3><p>在获取到javaChannel中的读取的数据之后，就发起了channelRead事件链，这里的pipeline是NioSocketChannel的事件链（看pipeline事件触发时，要看清楚pipeline是属于哪个Channel，这将影响后面的逻辑分析）。</p><p>最终会运行childHandler的channelRead方法，也就是开发者自定义的handler，这里其实就是把事件传给了开发人员的逻辑里面了。</p><p>以Netty提供的Echo例子为例，它的childHandler是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">        ctx.write(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Close the connection when an exception is raised.</span></span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接将读到的数据使用ctx.write(msg)方法写回到客户端，也就是echo服务。</p><p>这里解释一下@Sharable：</p><h3 id="Sharable"><a href="#Sharable" class="headerlink" title="@Sharable"></a>@Sharable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Indicates that the same instance of the annotated &#123;<span class="doctag">@link</span> ChannelHandler&#125;</span></span><br><span class="line"><span class="comment"> * can be added to one or more &#123;<span class="doctag">@link</span> ChannelPipeline&#125;s multiple times</span></span><br><span class="line"><span class="comment"> * without a race condition.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * If this annotation is not specified, you have to create a new handler</span></span><br><span class="line"><span class="comment"> * instance every time you add it to a pipeline because it has unshared</span></span><br><span class="line"><span class="comment"> * state such as member variables.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * This annotation is provided for documentation purpose, just like</span></span><br><span class="line"><span class="comment"> * &lt;a href=&quot;http://www.javaconcurrencyinpractice.com/annotations/doc/&quot;&gt;the JCIP annotations&lt;/a&gt;.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>表示一个ChannelHandler是否是可以多个Pipeline共享的，可以和：是否是可重入的、是否是可以并发调用的、是否是线程安全的、是否是单例的这几个问题结合起来理解Sharable。</p><p>1️⃣</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前面我们仔细分析过NioEventLoop的源码，以及找到了Netty事件驱动的源头代码：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;</summary>
      
    
    
    
    <category term="Netty" scheme="https://www.jelliclecat.cn/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://www.jelliclecat.cn/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty源码-4-ChannelPipeline</title>
    <link href="https://www.jelliclecat.cn/articles/Netty/netty-4/"/>
    <id>https://www.jelliclecat.cn/articles/Netty/netty-4/</id>
    <published>2019-09-20T15:32:41.000Z</published>
    <updated>2021-06-25T13:47:33.061Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">* &lt;pre&gt;</span><br><span class="line">*                                                 I/O Request</span><br><span class="line">*                                            via &#123;<span class="meta">@link</span> Channel&#125; or</span><br><span class="line">*                                        &#123;<span class="meta">@link</span> ChannelHandlerContext&#125;</span><br><span class="line">*                                                      |</span><br><span class="line">*  +---------------------------------------------------+---------------+</span><br><span class="line">*  |                           ChannelPipeline         |               |</span><br><span class="line">*  |                                                  \|/              |</span><br><span class="line">*  |    +---------------------+            +-----------+----------+    |</span><br><span class="line">*  |    | Inbound Handler  N  |            | Outbound Handler  <span class="number">1</span>  |    |</span><br><span class="line">*  |    +----------+----------+            +-----------+----------+    |</span><br><span class="line">*  |              /|\                                  |               |</span><br><span class="line">*  |               |                                  \|/              |</span><br><span class="line">*  |    +----------+----------+            +-----------+----------+    |</span><br><span class="line">*  |    | Inbound Handler N-<span class="number">1</span> |            | Outbound Handler  <span class="number">2</span>  |    |</span><br><span class="line">*  |    +----------+----------+            +-----------+----------+    |</span><br><span class="line">*  |              /|\                                  .               |</span><br><span class="line">*  |               .                                   .               |</span><br><span class="line">*  | ChannelHandlerContext.fireIN_EVT() ChannelHandlerContext.OUT_EVT()|</span><br><span class="line">*  |        [ method call]                       [method call]         |</span><br><span class="line">*  |               .                                   .               |</span><br><span class="line">*  |               .                                  \|/              |</span><br><span class="line">*  |    +----------+----------+            +-----------+----------+    |</span><br><span class="line">*  |    | Inbound Handler  <span class="number">2</span>  |            | Outbound Handler M-<span class="number">1</span> |    |</span><br><span class="line">*  |    +----------+----------+            +-----------+----------+    |</span><br><span class="line">*  |              /|\                                  |               |</span><br><span class="line">*  |               |                                  \|/              |</span><br><span class="line">*  |    +----------+----------+            +-----------+----------+    |</span><br><span class="line">*  |    | Inbound Handler  <span class="number">1</span>  |            | Outbound Handler  M  |    |</span><br><span class="line">*  |    +----------+----------+            +-----------+----------+    |</span><br><span class="line">*  |              /|\                                  |               |</span><br><span class="line">*  +---------------+-----------------------------------+---------------+</span><br><span class="line">*                  |                                  \|/</span><br><span class="line">*  +---------------+-----------------------------------+---------------+</span><br><span class="line">*  |               |                                   |               |</span><br><span class="line">*  |       [ Socket.read() ]                    [ Socket.write() ]     |</span><br><span class="line">*  |                                                                   |</span><br><span class="line">*  |  Netty Internal I/<span class="function">O <span class="title">Threads</span> <span class="params">(Transport Implementation)</span>            |</span></span><br><span class="line"><span class="function">*  +-------------------------------------------------------------------+</span></span><br><span class="line"><span class="function">* &lt;/pre&gt;</span></span><br></pre></td></tr></table></figure><p>这里先帖一段ChannelPipeline.java的注释。</p><p>其实pipeline比起三篇博客中介绍的类要简单很多，简单总结如下：</p><p>一个Channel对应一个pipeline。</p><p>一个Channel对应一个EventLoop。</p><p>一个Pipeline中有一个双向链表，链表中保存着两种PipelineHandler：Inbound和Outbound。</p><p>入站事件（比如read）会触发所有的InboundHandler中的逻辑，方向从head-&gt;tail。</p><p>出站事件（比如write）会触发OutboundHandler中的逻辑，方向从tail-&gt;head。</p><p>PipelineHandler并不是直接存在Pipeline中，而是使用了ChannelHandlerContext包装了一下，链表由ChannelHandlerContext构成。</p><p>结合这些理解，上图中注释就很容易理解了。</p><p>具体内容不分析了，比较简单。</p><p><a href="https://blog.csdn.net/u013967175/article/details/78604507">Netty源码分析（三）—数据管道ChannelPipeline源码分析</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=</summary>
      
    
    
    
    <category term="Netty" scheme="https://www.jelliclecat.cn/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://www.jelliclecat.cn/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty源码-3-ServerBootstrap</title>
    <link href="https://www.jelliclecat.cn/articles/Netty/netty-3/"/>
    <id>https://www.jelliclecat.cn/articles/Netty/netty-3/</id>
    <published>2019-09-20T00:55:10.000Z</published>
    <updated>2021-06-25T13:47:33.043Z</updated>
    
    <content type="html"><![CDATA[<p>前面的两篇博客分别分析了NioEventLoopGroup和NioEventLoop这两个类的创建以及重要功能，这为这篇博客全面分析Netty的启动类ServerBootstrap奠定了基础。</p><p>先回顾一下Server的核心启动代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"><span class="keyword">final</span> EchoServerHandler serverHandler = <span class="keyword">new</span> EchoServerHandler();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">    b.group(bossGroup, workerGroup)</span><br><span class="line">     .channel(NioServerSocketChannel.class)</span><br><span class="line">     .option(ChannelOption.SO_BACKLOG, <span class="number">100</span>)</span><br><span class="line">     .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">     .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">             ChannelPipeline p = ch.pipeline();</span><br><span class="line">             p.addLast(serverHandler);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start the server.</span></span><br><span class="line">    ChannelFuture f = b.bind(PORT).sync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait until the server socket is closed.</span></span><br><span class="line">    f.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// Shut down all event loops to terminate all threads.</span></span><br><span class="line">    bossGroup.shutdownGracefully();</span><br><span class="line">    workerGroup.shutdownGracefully();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到创建ServerBootstrap的过程，最后调用<code>b.bind(PORT)</code>将服务绑定到端口上。</p><p>ServerBootstrap的构造函数什么也没有干，核心的内容都在bind方法中，所以接下来我们重点分析bind方法，看看netty究竟是怎么启动的。</p><h2 id="bind方法"><a href="#bind方法" class="headerlink" title="bind方法"></a>bind方法</h2><p>所有的重载的bind方法最终都调用了doBind方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">        <span class="comment">// At this point we know that the registration was complete and successful.</span></span><br><span class="line">        ChannelPromise promise = channel.newPromise();</span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Registration future is almost always fulfilled already, but just in case it&#x27;s not.</span></span><br><span class="line">        <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</span><br><span class="line">        regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Throwable cause = future.cause();</span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span></span><br><span class="line">                    <span class="comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span></span><br><span class="line">                    promise.setFailure(cause);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Registration was successful, so set the correct executor to use.</span></span><br><span class="line">                    <span class="comment">// See https://github.com/netty/netty/issues/2586</span></span><br><span class="line">                    promise.registered();</span><br><span class="line"></span><br><span class="line">                    doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面干了两件事情：</p><ul><li>调用initAndRegister方法创建Channel并注册Nio事件</li><li>调用doBind0触发pipeline中的事件链</li></ul><h2 id="initAndRegister方法"><a href="#initAndRegister方法" class="headerlink" title="initAndRegister方法"></a>initAndRegister方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Channel channel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPromise(<span class="keyword">new</span> FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">    &#125;</span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            channel.unsafe().closeForcibly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法里面主要干了三件事情：</p><ul><li>使用channelFactory创建channel</li><li>使用init方法初始化channel</li><li>最后调用config().group().register(channel)将刚刚创建的channel绑定到一个EventLoop上（就是一个NioEventLoop上）</li></ul><h3 id="1-channelFactory创建channel"><a href="#1-channelFactory创建channel" class="headerlink" title="1. channelFactory创建channel"></a>1. channelFactory创建channel</h3><p>首先弄清楚channelFactory是什么，当我们调用ServerBootstrap的channel方法时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b.group(bossGroup, workerGroup)</span><br><span class="line"> .channel(NioServerSocketChannel.class)</span><br></pre></td></tr></table></figure><p>调用的实际上是父类AbstractBootstrap的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (channelClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;channelClass&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> channelFactory(<span class="keyword">new</span> ReflectiveChannelFactory&lt;C&gt;(channelClass));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channelFactory</span><span class="params">(ChannelFactory&lt;? extends C&gt; channelFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (channelFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;channelFactory&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.channelFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;channelFactory set already&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.channelFactory = channelFactory;</span><br><span class="line">    <span class="keyword">return</span> self();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用AbstractBootstrap#channel方法时，创建了一个ReflectiveChannelFactory对象，并最终赋值给了channelFactory。</p><p>到这里我们就知道了channelFactory其实是一个ReflectiveChannelFactory实例，那继续看看ReflectiveChannelFactory是什么东西：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectiveChannelFactory</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt; <span class="keyword">implements</span> <span class="title">ChannelFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;? extends T&gt; clazz;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReflectiveChannelFactory</span><span class="params">(Class&lt;? extends T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;clazz&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.clazz = clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">newChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> clazz.getConstructor().newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">&quot;Unable to create Channel from class &quot;</span> + clazz, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StringUtil.simpleClassName(clazz) + <span class="string">&quot;.class&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReflectiveChannelFactory其实就是用反射去创建一个新的Channel，也就是我们传入的NioServerSocketChannel，所以看到这里就明白了，initAndRegister方法初始化和注册的是NioServerSocketChannel这个Channel。</p><p>看一下NioServerSocketChannel创建的大致过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">null</span>, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">    config = <span class="keyword">new</span> NioServerSocketChannelConfig(<span class="keyword">this</span>, javaChannel().socket());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了父类的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="keyword">int</span> readInterestOp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    <span class="keyword">this</span>.ch = ch;</span><br><span class="line">    <span class="keyword">this</span>.readInterestOp = readInterestOp;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ch.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ch.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                logger.warn(</span><br><span class="line">                        <span class="string">&quot;Failed to close a partially initialized socket.&quot;</span>, e2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">&quot;Failed to enter non-blocking mode.&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里最重要的是，将SelectionKey.OP_ACCEPT赋值给了readInterestOp属性，这个在之后向Selector中注册的时候会用到。</p><p>这里分析一下为什么只关心SelectionKey.OP_ACCEPT事件，记得ServerBootstrap传入了两个EventLoopGroup，分别命名为bossGroup和workerGroup，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br></pre></td></tr></table></figure><p>bossGroup和workerGroup的职责不同，bossGroup专门负责接收客户端的链接，一旦连接建立，就会把接下来的io读写工作交给workerGroup，这也是为什么bossGroup在new的时候只需要一个线程了。workerGroup才是执行io读写工作的线程，所以命名为工作线程。NioServerSocketChannel是处理客户端连接的Channel，所以它关心的事件只有SelectionKey.OP_ACCEPT。</p><p>在AbstractNioChannel的构造函数中还调用了父类AbstractChannel的构造函数，AbstractChannel构造函数干了三件事情：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id = newId();</span><br><span class="line">unsafe = newUnsafe();</span><br><span class="line">pipeline = newChannelPipeline();</span><br></pre></td></tr></table></figure><p>比较重要的是创建了unsafe实例和pipeline实例，这里的unsafe不同于sun包中的unsafe，后面会仔细分析，这里只用知道这两个实例被初始化了。pipeline是Netty中另一个核心构建，如果说NioEventLoop是心脏，那pipeline就是血管了。这里创建的pipeline是DefaultChannelPipeline，记住这一点后，后面分析的pipeline的方法实现都在DefaultChannelPipeline中。这里简化了我们的分析，不用去找多个父类和多个实现才知道最终的方法。</p><p>当使用channelFactory创建完Channel之后，调用init方法去初始化这个channel。</p><h3 id="2-init方法初始化channel"><a href="#2-init方法初始化channel" class="headerlink" title="2. init方法初始化channel"></a>2. init方法初始化channel</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 剔除掉一些无用的方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line">    p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            ChannelHandler handler = config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剔除掉一些不管心的方法之后，这里的功能就比较清晰了，首先通过channel.pipeline()方法获取pipeline，这里的pipeline就是上文中创建的DefaultChannelPipeline。</p><p>然后pipeline中增加了一个ChannelHandle，ChannelHandle在对应事件触发的时候回调ChannelHandle里面的一些方法，所以这个类里面的方法是异步执行的。</p><p><strong>稍微看一下这个ChannelInitializer：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Sharable</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">C</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt; <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">PlatformDependent.newConcurrentHashMap();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(C ch)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initChannel(ctx)) &#123;</span><br><span class="line">            ctx.pipeline().fireChannelRegistered();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.fireChannelRegistered();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>initChannel方法实际是在channelRegistered被回调的时候调用的，这里mark一下。</p><p>在initChannel方法中，最重要的是往自己的事件处理连中添加了一个ServerBootstrapAcceptor。</p><p>上文已经分析过了，NioServerSocketChannel的作用其实就是监听并接受客户端的连接请求，连接建立完成之后，就会扔给worker线程。这里的ServerBootstrapAcceptor就是干这个用的，看一下ServerBootstrapAcceptor的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Channel child = (Channel) msg;</span><br><span class="line"></span><br><span class="line">    child.pipeline().addLast(childHandler);</span><br><span class="line"></span><br><span class="line">    setChannelOptions(child, childOptions, logger);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;</span><br><span class="line">        child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                    forceClose(child, future.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        forceClose(child, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当NioServerSocketChannel监听到SelectionKey.OP_ACCEPT时间后，会触发pipeline中的channelRead事件链，最终会执行ServerBootstrapAcceptor中的channelRead方法。这个方法调用childGroup.register(child)将客户端和服务端建立的连接，也就是这里传进来的msg（一个Channel实例）注册进childGroup。childGroup（一个NioEventLoopGroup实例）会从自己的children（一个NioEventLoop数组）中选出一个NioEventLoop去接纳这个新的Channel。</p><p>到这里init方法就执行完了，注意这里的很多动作其实都仅仅注册了一个回调函数，还没有被真正的执行。</p><p>接下来看看config().group().register(channel)。</p><h3 id="3-config-group-register-channel"><a href="#3-config-group-register-channel" class="headerlink" title="3. config().group().register(channel)"></a>3. config().group().register(channel)</h3><p>config方法返回的是一个ServerBootstrapConfig实例，这部分代码朋友们可以自己跟踪，比较简单。</p><p>ServerBootstrapConfig#group方法返回的其实就是ServerBootstrap中的group，这里的group是bossGroup，同样大家跟踪一下这部分代码，不再赘述了。关键我们看group.register(channel)干了什么：</p><p>首先，调用NioEventLoopGroup#register方法实际调用了父类MultithreadEventLoopGroup#register方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MultithreadEventLoopGroup.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> next().register(channel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后先调用了一个next方法，调用的是父类MultithreadEventExecutorGroup#next方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EventExecutor <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> chooser.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了chooser.next()，看过上篇博客的朋友们肯定有印象，这个chooser其实就是从NioEventLoopGroup的children数组中选出一个NioEventLoop。</p><p>回到MultithreadEventLoopGroup#register方法中，这里的next().register(channel)其实调用的是NioEventLoop#register方法：</p><p>（这里比较绕，多看几遍这部分）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SingleThreadEventLoop.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> register(<span class="keyword">new</span> DefaultChannelPromise(channel, <span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ObjectUtil.checkNotNull(promise, <span class="string">&quot;promise&quot;</span>);</span><br><span class="line">    promise.channel().unsafe().register(<span class="keyword">this</span>, promise);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用的是unsafe的register方法：</p><p>这里调用register方法时，将自己传进去了，也就是一个EventLoop，这步的作用其实就是将这个Channel和一个EventLoop绑定起来了，或者说将Channel注册到了EventLoop中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractChannel.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (eventLoop == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;eventLoop&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRegistered()) &#123;</span><br><span class="line">        promise.setFailure(<span class="keyword">new</span> IllegalStateException(<span class="string">&quot;registered to an event loop already&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isCompatible(eventLoop)) &#123;</span><br><span class="line">        promise.setFailure(</span><br><span class="line">                <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;incompatible event loop type: &quot;</span> + eventLoop.getClass().getName()));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.warn(</span><br><span class="line">                    <span class="string">&quot;Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;&quot;</span>,</span><br><span class="line">                    AbstractChannel.<span class="keyword">this</span>, t);</span><br><span class="line">            closeForcibly();</span><br><span class="line">            closeFuture.setClosed();</span><br><span class="line">            safeSetFailure(promise, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面有一个<code>AbstractChannel.this.eventLoop = eventLoop;</code>，可以印证我们刚刚分析的，这里将传进来的EventLoop赋值到了自己的eventLoop对象上，还记的上面的init方法中，最后有一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里ch.eventLoop()拿到的其实就是刚刚赋值的eventLoop对象。</p><p>哎这里是不是很奇怪，ch.eventLoop()这步是在eventLoop对象被赋值之前调用的啊，这时拿到的eventLoop难道不是null嘛？这就是上面反复提到过的，这里的ch.eventLoop()其实并没有执行，只是注册了一个回调函数，当它真正被调用执行的时候，eventLoop已经被赋值了。</p><p>继续看AbstractChannel的register方法，这个方法调用了register0：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line">                doRegister();</span><br><span class="line">                neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">                registered = <span class="keyword">true</span>;</span><br><span class="line">                pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line">                safeSetSuccess(promise);</span><br><span class="line">                pipeline.fireChannelRegistered();</span><br><span class="line">                <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                        pipeline.fireChannelActive();</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                        beginRead();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                closeForcibly();</span><br><span class="line">                closeFuture.setClosed();</span><br><span class="line">                safeSetFailure(promise, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这段代码干了两件重要的事情：</p><ul><li>doRegister</li><li>beginRead</li></ul><p>这两个后面分析。这里还做了一件重要的事情，调用了<code>pipeline.fireChannelRegistered();</code>，这里触发了pipeline中的注册事件链，注册事件链比较特殊，上文提到过，ChannelInitializer的initChannel方法实际是由channelRegistered方法触发的。</p><h4 id="1-doRegister"><a href="#1-doRegister" class="headerlink" title="1.doRegister"></a>1.doRegister</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> selected = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!selected) &#123;</span><br><span class="line">                    eventLoop().selectNow();</span><br><span class="line">                    selected = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>看到了重要的一个调用：</p><p><code>selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);</code>，这里selectionKey是JDK的selectionKey，javaChannel返回的是JDK的Channel，然后将eventLoop中的Selector注册进了这个Channel中，到这里总算是落地到JDK的代码上了，到这里，Nio Server算是真正的启动了。</p><p>这里还没完，这里注册的interestOps是0，0不是任何一个Nio事件，所以这里其实是借助register方法初始化selectionKey，并没有开始真正的监听Nio事件。这里将自己作为attachment传进SelectionKey，之后会反过来从SelectionKey中取这个NettyChannel。</p><h4 id="2-beginRead"><a href="#2-beginRead" class="headerlink" title="2.beginRead"></a>2.beginRead</h4><p>刚刚说了，doRegister方法中并没有开启真正的事件监听，那唯一的可能就是在beginRead中开启监听了：</p><p>进过一顿寻找，发现最终beginRead调用了这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractNioChannel.java</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> SelectionKey selectionKey = <span class="keyword">this</span>.selectionKey;</span><br><span class="line">    <span class="keyword">if</span> (!selectionKey.isValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    readPending = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> interestOps = selectionKey.interestOps();</span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;</span><br><span class="line">        selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里将刚刚创建的selectionKey中的interestOps换成了在AbstractNioChannel构造的时候传进来的interestOps，文章开头看到了，最初传进来的interestOps是SelectionKey.OP_ACCEPT事件，所以最后selectionKey绑定的事件就是SelectionKey.OP_ACCEPT事件。</p><h2 id="doBind方法"><a href="#doBind方法" class="headerlink" title="doBind方法"></a>doBind方法</h2><p>这个方法就很简单了，就是触发了pipeline中的bind事件链，并最终调用JDK绑定到端口，这里最后调用JDK的代码比较难找，最开始我找了好久也没有找到是在哪里调用的，仔细梳理了一遍之后发现，触发pipeline中的bind事件链中，bind事件被定义为出站事件，所以事件会从tail流到head，我们去看那一下DefaultChannelPipeline中的headContext：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadContext</span> <span class="keyword">extends</span> <span class="title">AbstractChannelHandlerContext</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ChannelOutboundHandler</span>, <span class="title">ChannelInboundHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Unsafe unsafe;</span><br><span class="line"></span><br><span class="line">    HeadContext(DefaultChannelPipeline pipeline) &#123;</span><br><span class="line">        <span class="keyword">super</span>(pipeline, <span class="keyword">null</span>, HEAD_NAME, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        unsafe = pipeline.channel().unsafe();</span><br><span class="line">        setAddComplete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelHandler <span class="title">handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// NOOP</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// NOOP</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        unsafe.bind(localAddress, promise);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终委托给了unsafe#bind方法，后面的代码跟踪就比较简单了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们看到，在注册这一步的时候，绕了好大一个弯，从NioEventLoopGroup#register到NioEventLoop#register再到Unsafe#register方法。</p><p>从NioEventLoopGroup#register到NioEventLoop#register这步，其实是从EventLoopGroup选出一个EventLoop（通过调用next方法），NioEventLoop#register到Unsafe#register这步，其实是将NioEventLoop绑定到Channel，这里Unsafe是Channel的内部类，最终，Unsafe调用了JDK的Nio register方法创建了一个selectionKey。Unsafe最后还点燃了pipeline的register事件链，并最终绑定了SelectionKey.OP_ACCEPT事件。</p><p>这里分一下Unsafe这个命名，与JDK打交道的功能封装在Unsafe中，它是连接Netty Nio与JDK Nio的桥梁，那为什么要命名为Unsafe呢？这里就很有趣了：</p><p>我们熟悉Sun提供的Unsafe工具，这个工具可以与一些底层直接进行交互，比如CAS，比如堆外内存的使用，这里命名为Unsafe的意思是说，这些东西都不属于JVM管理的，请知晓，JVM是不保证这些操作的安全性的！</p><p>在Netty中就很有意思了，Netty是在说谁Unsafe呢？其实说的是JDK，Netty说JDK是Unsafe的，因为对于Netty来说，JDK中的代码是不受自己控制的，调用JDK出了问题Netty是无能为力的，Netty同样不能保证JDK的安全！所以与JDK打交道的代码被称为Unsafe。</p><p>这样的话，在以后自己写框架的过程中，如果需要对其他的依赖的框架做一些封装，那这个封装的类也可以被命名为Unsafe，告诉别人，这个类里面的功能都是别人的！我不能保证安全性！我只是提供一层封装！（虽然我自己可能不会这么去做^_^）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前面的两篇博客分别分析了NioEventLoopGroup和NioEventLoop这两个类的创建以及重要功能，这为这篇博客全面分析Netty的启动类ServerBootstrap奠定了基础。&lt;/p&gt;
&lt;p&gt;先回顾一下Server的核心启动代码：&lt;/p&gt;
&lt;figure c</summary>
      
    
    
    
    <category term="Netty" scheme="https://www.jelliclecat.cn/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://www.jelliclecat.cn/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty源码-2-NioEventLoop</title>
    <link href="https://www.jelliclecat.cn/articles/Netty/netty-2/"/>
    <id>https://www.jelliclecat.cn/articles/Netty/netty-2/</id>
    <published>2019-09-19T01:12:28.000Z</published>
    <updated>2021-06-25T13:47:33.049Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>长文预警！！！</p></blockquote><h2 id="一、NioEventLoop概要"><a href="#一、NioEventLoop概要" class="headerlink" title="一、NioEventLoop概要"></a>一、NioEventLoop概要</h2><p>NioEventLoop就是上文中NioEventLoopGroup的children，可以先通过名字分析一下这个类的作用，这个类名有三个单词：Nio、Event、Loop。</p><p>通过Loop可以猜测，这个类里面有一个死循环，死循环的逻辑一般都会扔给一个单独的线程，所以可以猜测NioEventLoop中会管理一个线程或者线程池，这个线程中用来执行死循环逻辑，既然涉及到线程或者线程池，那么还要有管理线程生命周期的方法。如果是线程池，那就会有线程池相关的一些逻辑，比如线程池的拒绝策略等等。</p><p>通过Event可以猜测到，死循环执行的逻辑是在监听某一个或一类事件，监听过程一定是阻塞的。</p><p>通过Nio可以知道，上面提到的Event是Nio中的事件，而且是SocketNio的事件，SocketNio的事件定义在SelectionKey中，有四种事件，读事件，写事件，客户端的连接事件，服务端的接收事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_READ = <span class="number">1</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WRITE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_CONNECT = <span class="number">1</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_ACCEPT = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>通过上面的猜测总结一下NioEventLoop的功能：开启一个线程循环监听Socket Nio中的事件。</p><p>接下来看下源码：</p><p>接着上文，创建NioEventLoop的入口在NioEventLoopGroup中，上文讲了NioEventLoopGroup构造时，会根据nThread参数创建相应大小的children数组，children数组实际上就是NioEventLoop数组，MultithreadEventExecutorGroup中的<code>newChild</code>方法是一个模板方法，实现在NioEventLoopGroup中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> EventLoop <span class="title">newChild</span><span class="params">(Executor executor, Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> NioEventLoop(<span class="keyword">this</span>, executor, (SelectorProvider) args[<span class="number">0</span>],</span><br><span class="line">            ((SelectStrategyFactory) args[<span class="number">1</span>]).newSelectStrategy(), (RejectedExecutionHandler) args[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到就是new了一个NioEventLoop，这里注意一下传入的参数：</p><ul><li>executor</li><li>SelectorProvider</li><li>SelectStrategyFactory （先不管）</li><li>RejectedExecutionHandler</li></ul><p>这里印证了一些上文的猜测，我们挨个看一下这几个参数（其实这里面的参数都在上文中提到过）：</p><h3 id="1-executor"><a href="#1-executor" class="headerlink" title="1. executor"></a>1. executor</h3><p>上文中讲过了executor的创建，这里复习一下，executor是一个netty中自己定义的线程池：ThreadPerTaskExecutor，从名字就能看出，这个线程池为每一个新的任务都创建一个新的线程去执行，这个线程池最主要的作用是，从这个线程池中创建出来的每一个线程都是Netty自定义的线程：FastThreadLocalThread，这个线程池中使用的是FastThreadLocal而不是jdk原生的ThreadLocal，FastThreadLocal比ThreadLocal更快，因为FastThreadLocal没有算hash，并解决了伪共享的问题。</p><p>这里创建FastThreadLocal并不是ThreadPerTaskExecutor本身的功能，而是因为MultithreadEventExecutorGroup创建ThreadPerTaskExecutor时传入的是DefaultThreadFactory，真正负责创建FastThreadLocal的类实际是DefaultThreadFactory。</p><h3 id="2-SelectorProvider"><a href="#2-SelectorProvider" class="headerlink" title="2. SelectorProvider"></a>2. SelectorProvider</h3><p>这是Java中的原生类，用来获取一个Selector。</p><h3 id="3-RejectedExecutionHandler"><a href="#3-RejectedExecutionHandler" class="headerlink" title="3. RejectedExecutionHandler"></a>3. RejectedExecutionHandler</h3><p>对应的executor的拒绝策略。</p><h2 id="二、构造NioEventLoop"><a href="#二、构造NioEventLoop" class="headerlink" title="二、构造NioEventLoop"></a>二、构造NioEventLoop</h2><p>看了构造函数的参数之后，再看一下构造的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,</span><br><span class="line">             SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) &#123;</span><br><span class="line">    <span class="keyword">super</span>(parent, executor, <span class="keyword">false</span>, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler);</span><br><span class="line">    <span class="keyword">if</span> (selectorProvider == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;selectorProvider&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (strategy == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;selectStrategy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    provider = selectorProvider;</span><br><span class="line">    <span class="keyword">final</span> SelectorTuple selectorTuple = openSelector();</span><br><span class="line">    selector = selectorTuple.selector;</span><br><span class="line">    unwrappedSelector = selectorTuple.unwrappedSelector;</span><br><span class="line">    selectStrategy = strategy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用了父类的构造函数，看一下SingleThreadEventExecutor这个父类的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SingleThreadEventExecutor</span><span class="params">(EventExecutorGroup parent, Executor executor,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="keyword">boolean</span> addTaskWakesUp, <span class="keyword">int</span> maxPendingTasks,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    RejectedExecutionHandler rejectedHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    <span class="keyword">this</span>.addTaskWakesUp = addTaskWakesUp;</span><br><span class="line">    <span class="keyword">this</span>.maxPendingTasks = Math.max(<span class="number">16</span>, maxPendingTasks);</span><br><span class="line">    <span class="keyword">this</span>.executor = ObjectUtil.checkNotNull(executor, <span class="string">&quot;executor&quot;</span>);</span><br><span class="line">    taskQueue = newTaskQueue(<span class="keyword">this</span>.maxPendingTasks);</span><br><span class="line">    rejectedExecutionHandler = ObjectUtil.checkNotNull(rejectedHandler, <span class="string">&quot;rejectedHandler&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文中提到的几个参数，在这里都有体现了，父类构造也比较简单，只是进行了简单的赋值。</p><p>继续看NioEventLoop的构造函数，构造函数中，除了一些赋值之外，执行了一个重要的方法：openSelector()，这个方法用来获取Selector：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SelectorTuple <span class="title">openSelector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Selector unwrappedSelector;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            unwrappedSelector = provider.openSelector();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">&quot;failed to open a new selector&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DISABLE_KEYSET_OPTIMIZATION) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SelectorTuple(unwrappedSelector);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object maybeSelectorImplClass = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> Class.forName(</span><br><span class="line">                            <span class="string">&quot;sun.nio.ch.SelectorImpl&quot;</span>,</span><br><span class="line">                            <span class="keyword">false</span>,</span><br><span class="line">                            PlatformDependent.getSystemClassLoader());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">                    <span class="keyword">return</span> cause;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(maybeSelectorImplClass <span class="keyword">instanceof</span> Class) ||</span><br><span class="line">            <span class="comment">// ensure the current selector implementation is what we can instrument.</span></span><br><span class="line">            !((Class&lt;?&gt;) maybeSelectorImplClass).isAssignableFrom(unwrappedSelector.getClass())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maybeSelectorImplClass <span class="keyword">instanceof</span> Throwable) &#123;</span><br><span class="line">                Throwable t = (Throwable) maybeSelectorImplClass;</span><br><span class="line">                logger.trace(<span class="string">&quot;failed to instrument a special java.util.Set into: &#123;&#125;&quot;</span>, unwrappedSelector, t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SelectorTuple(unwrappedSelector);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; selectorImplClass = (Class&lt;?&gt;) maybeSelectorImplClass;</span><br><span class="line">        <span class="keyword">final</span> SelectedSelectionKeySet selectedKeySet = <span class="keyword">new</span> SelectedSelectionKeySet();</span><br><span class="line"></span><br><span class="line">        Object maybeException = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Field selectedKeysField = selectorImplClass.getDeclaredField(<span class="string">&quot;selectedKeys&quot;</span>);</span><br><span class="line">                    Field publicSelectedKeysField = selectorImplClass.getDeclaredField(<span class="string">&quot;publicSelectedKeys&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">9</span> &amp;&amp; PlatformDependent.hasUnsafe()) &#123;</span><br><span class="line">                        <span class="comment">// Let us try to use sun.misc.Unsafe to replace the SelectionKeySet.</span></span><br><span class="line">                        <span class="comment">// This allows us to also do this in Java9+ without any extra flags.</span></span><br><span class="line">                        <span class="keyword">long</span> selectedKeysFieldOffset = PlatformDependent.objectFieldOffset(selectedKeysField);</span><br><span class="line">                        <span class="keyword">long</span> publicSelectedKeysFieldOffset =</span><br><span class="line">                                PlatformDependent.objectFieldOffset(publicSelectedKeysField);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (selectedKeysFieldOffset != -<span class="number">1</span> &amp;&amp; publicSelectedKeysFieldOffset != -<span class="number">1</span>) &#123;</span><br><span class="line">                            PlatformDependent.putObject(</span><br><span class="line">                                    unwrappedSelector, selectedKeysFieldOffset, selectedKeySet);</span><br><span class="line">                            PlatformDependent.putObject(</span><br><span class="line">                                    unwrappedSelector, publicSelectedKeysFieldOffset, selectedKeySet);</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// We could not retrieve the offset, lets try reflection as last-resort.</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Throwable cause = ReflectionUtil.trySetAccessible(selectedKeysField, <span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> cause;</span><br><span class="line">                    &#125;</span><br><span class="line">                    cause = ReflectionUtil.trySetAccessible(publicSelectedKeysField, <span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> cause;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    selectedKeysField.set(unwrappedSelector, selectedKeySet);</span><br><span class="line">                    publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (maybeException <span class="keyword">instanceof</span> Exception) &#123;</span><br><span class="line">            selectedKeys = <span class="keyword">null</span>;</span><br><span class="line">            Exception e = (Exception) maybeException;</span><br><span class="line">            logger.trace(<span class="string">&quot;failed to instrument a special java.util.Set into: &#123;&#125;&quot;</span>, unwrappedSelector, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SelectorTuple(unwrappedSelector);</span><br><span class="line">        &#125;</span><br><span class="line">        selectedKeys = selectedKeySet;</span><br><span class="line">        logger.trace(<span class="string">&quot;instrumented a special java.util.Set into: &#123;&#125;&quot;</span>, unwrappedSelector);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SelectorTuple(unwrappedSelector,</span><br><span class="line">                                 <span class="keyword">new</span> SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这个方法有看起来非常复杂，但其实有一个开关：DISABLE_KEYSET_OPTIMIZATION：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DISABLE_KEYSET_OPTIMIZATION =</span><br><span class="line">            SystemPropertyUtil.getBoolean(<span class="string">&quot;io.netty.noKeySetOptimization&quot;</span>, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>默认是false。</p><p>先看如果是true怎么办，如果是true，那么直接返回了SelectorProvider的openSelector方法返回的Selector，这里简单包装了一下，SelectorTuple，但是其实什么也没干，然后这个方法就直接返回了。</p><p>这里有两个问题：SelectorProvider的openSelector获得的是什么Selector？如果DISABLE_KEYSET_OPTIMIZATION是false怎么办？咱们一个一个看：</p><h3 id="1-SelectorProvider的openSelector方法"><a href="#1-SelectorProvider的openSelector方法" class="headerlink" title="1. SelectorProvider的openSelector方法"></a>1. SelectorProvider的openSelector方法</h3><p>这里的SelectorProvider是使用SelectorProvider.provider()方法获取的SelectorProvider是sun.nio.ch.DefaultSelectorProvider.create()返回的SelectorProvider：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">provider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (provider != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> provider;</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(</span><br><span class="line">            <span class="keyword">new</span> PrivilegedAction&lt;SelectorProvider&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> SelectorProvider <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (loadProviderFromProperty())</span><br><span class="line">                            <span class="keyword">return</span> provider;</span><br><span class="line">                        <span class="keyword">if</span> (loadProviderAsService())</span><br><span class="line">                            <span class="keyword">return</span> provider;</span><br><span class="line">                        provider = sun.nio.ch.DefaultSelectorProvider.create();</span><br><span class="line">                        <span class="keyword">return</span> provider;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而sun.nio.ch.DefaultSelectorProvider.create()返回的是KQueueSelectorProvider。所以SelectorProvider的openSelector方法实际是调用的KQueueSelectorProvider的openSelector方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSelectorProvider</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">DefaultSelectorProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SelectorProvider <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> KQueueSelectorProvider();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以体现出JDK的跨平台特性了，我使用的是iOS系统，所以返回的是KQueue，可以猜想，如果使用的是Linux系统，那这里返回的应该是Epoll，因为iOS和Linux的epoll系统调用不一样。</p><p>那第一个问题解决了，最终创建的Selector是KQueueSelectorImpl，使用了k-queue系统调用。</p><h3 id="2-DISABLE-KEYSET-OPTIMIZATION为false"><a href="#2-DISABLE-KEYSET-OPTIMIZATION为false" class="headerlink" title="2. DISABLE_KEYSET_OPTIMIZATION为false"></a>2. DISABLE_KEYSET_OPTIMIZATION为false</h3><p>传统，先看名字：DISABLE_KEYSET_OPTIMIZATION，禁用KeySet优化，默认是false，即默认是启用KeySet优化。</p><p>当DISABLE_KEYSET_OPTIMIZATION == true的时候，直接返回了KQueueSelectorImpl。</p><p>如果是false的时候，逻辑就稍微比较复杂一些，首先通过反射找到了sun.nio.ch.SelectorImpl这个类，这个类是KQueueSelectorImpl的父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectorImpl</span> <span class="keyword">extends</span> <span class="title">AbstractSelector</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> Set&lt;SelectionKey&gt; selectedKeys = <span class="keyword">new</span> HashSet();</span><br><span class="line">  <span class="keyword">protected</span> HashSet&lt;SelectionKey&gt; keys = <span class="keyword">new</span> HashSet();</span><br><span class="line">  <span class="keyword">private</span> Set&lt;SelectionKey&gt; publicKeys;</span><br><span class="line">  <span class="keyword">private</span> Set&lt;SelectionKey&gt; publicSelectedKeys;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">SelectorImpl</span><span class="params">(SelectorProvider var1)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(var1);</span><br><span class="line">    <span class="keyword">if</span> (Util.atBugLevel(<span class="string">&quot;1.4&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.publicKeys = <span class="keyword">this</span>.keys;</span><br><span class="line">      <span class="keyword">this</span>.publicSelectedKeys = <span class="keyword">this</span>.selectedKeys;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.publicKeys = Collections.unmodifiableSet(<span class="keyword">this</span>.keys);</span><br><span class="line">      <span class="keyword">this</span>.publicSelectedKeys = Util.ungrowableSet(<span class="keyword">this</span>.selectedKeys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ... 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续看下面的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Object maybeException = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Field selectedKeysField = selectorImplClass.getDeclaredField(<span class="string">&quot;selectedKeys&quot;</span>);</span><br><span class="line">            Field publicSelectedKeysField = selectorImplClass.getDeclaredField(<span class="string">&quot;publicSelectedKeys&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// ... 省略</span></span><br><span class="line">            selectedKeysField.set(unwrappedSelector, selectedKeySet);</span><br><span class="line">            publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看到，通过反射拿到了SelectorImpl的selectedKeys和publicSelectedKeys这两个Field，然后调用了set方法，替换掉了这两个Field的值。</p><p>用什么替换掉的呢？SelectedSelectionKeySet，为什么要用这个替换呢，替换掉的是什么呢？</p><p>看看SelectorImpl的构造函数，构造selectedKeys和publicSelectedKeys使用的是HashSet，所以实际上使用SelectedSelectionKeySet替换掉了HashSet。</p><p>看看SelectedSelectionKeySet：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectedSelectionKeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">SelectionKey</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    SelectionKey[] keys;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    SelectedSelectionKeySet() &#123;</span><br><span class="line">        keys = <span class="keyword">new</span> SelectionKey[<span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(SelectionKey o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        keys[size++] = o;</span><br><span class="line">        <span class="keyword">if</span> (size == keys.length) &#123;</span><br><span class="line">            increaseCapacity();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;SelectionKey&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;SelectionKey&gt;() &#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> idx;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> idx &lt; size;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> SelectionKey <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!hasNext()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> keys[idx++];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        reset(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        Arrays.fill(keys, start, size, <span class="keyword">null</span>);</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">increaseCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SelectionKey[] newKeys = <span class="keyword">new</span> SelectionKey[keys.length &lt;&lt; <span class="number">1</span>];</span><br><span class="line">        System.arraycopy(keys, <span class="number">0</span>, newKeys, <span class="number">0</span>, size);</span><br><span class="line">        keys = newKeys;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HashSet本身是基于HashMap实现的，而HashMap的插入会有很复杂的操作，链表、扩容、rehash、链表转红黑树等等操作，而这里这里并不需要这么复杂的操作，所以Netty直接用了一个数组代替，数组的顺序插入比HashMap的插入要高效得多。</p><p>所以简而言之，这里不需要使用HashSet，Netty认为SelectorImpl的实现不够高效，所以使用反射，将SelectorImpl中的selectedKeys和publicSelectedKeys替换为自己用数组实现的<strong>性能更好的</strong>SelectedSelectionKeySet。</p><p>到这里就能完全看出DISABLE_KEYSET_OPTIMIZATION的意思了，是否开启KeySet优化。</p><p>【BTW】，这种使用数组替换hash的方法在Netty中其实并不陌生，FastThreadLocal就是用数组的顺序添加替代JDK原生ThreadLocal中的hash。</p><p><strong>总结：</strong>这里没有Thread的启动逻辑诶，不是说NioEventLoop会管理自己的Thread，为什么没有在构造函数里面体现呢？这里可以这么认为，NioEventLoop的构造函数属于NioEventLoop的生命周期，而内部Thread的生命周期需要单独管理。换个角度思考，这里也可以说这是一种懒加载，只有在真正需要启动Thread的时候，再去启动，毕竟Thread是比较昂贵的系统资源。</p><h2 id="三、内部Thread的启动"><a href="#三、内部Thread的启动" class="headerlink" title="三、内部Thread的启动"></a>三、内部Thread的启动</h2><p>那内部的Thread是怎么启动的呢？</p><p>在构造函数中，我们看到executor被SingleThreadEventExecutor持有，我很好奇这个executor会怎么用呢？通过查找executor，找到了一个doStartThread方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> thread == <span class="keyword">null</span>;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                thread = Thread.currentThread();</span><br><span class="line">                <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">                    thread.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">                updateLastExecutionTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    SingleThreadEventExecutor.<span class="keyword">this</span>.run();</span><br><span class="line">                    success = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.warn(<span class="string">&quot;Unexpected exception from an event executor: &quot;</span>, t);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// ... 省略 更新状态位等收尾工作。</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>thread是SingleThreadEventExecutor持有的一个Thread引用。</p><p>这里调用了executor.execute方法，这里面的方法贼好玩，我们知道这个executor是ThreadPerTaskExecutor，看一下ThreadPerTaskExecutor的execute方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    threadFactory.newThread(command).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里从threadFactory创建了一个新的线程（threadFactory是DefaultThreadFactory，创建的是FastThreadLocalThread，后面不再赘述了，已经讲了很多遍了），然后doStartThread调用executor.execute方法中，进行了一步赋值：thread = Thread.currentThread()。</p><p>这个就很有味道了，首先Thread.currentThread()是什么，就是ThreadPerTaskExecutor刚刚创建出来的新线程，然后把这个新线程给了SingleThreadEventExecutor持有的Thread引用。</p><p>这样，SingleThreadEventExecutor持有的Thread引用其实是由DefaultThreadFactory创建出来的。</p><p>在给thread赋值之后，后面接着调用了SingleThreadEventExecutor.this.run()，即自己的run方法，待会着重看一下run方法。</p><p>最后做了一些收尾工作。所以我们能看到，前面说了这么久的内部线程，最后是在这里创建并启动的。</p><p>那么，doStartThread是什么时候调用的呢？直接查找可以看到startThread方法调用了doStartThread，而SingleThreadEventExecutor的execute方法调用了startThread方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;task&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> inEventLoop = inEventLoop();</span><br><span class="line">    addTask(task);</span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop) &#123;</span><br><span class="line">        startThread();</span><br><span class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp; removeTask(task)) &#123;</span><br><span class="line">            reject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</span><br><span class="line">        wakeup(inEventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>inEventLoop判断当前的线程是否是自己持有的thread，判断的方法是”==”，这样如果thread是null的话，就调用startThread创建线程。</p><p>到这里，我们就知道了NioEventLoop是如何创建并启动持有的thread了。</p><p>有朋友可能要问，哎，这个thread没有start啊，其实我们回头看ThreadPerTaskExecutor就知道了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    threadFactory.newThread(command).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了start，所以在Runnable内部通过Thread.currentThread()拿到的thread其实就已经启动了。这段代码真的玩的很花。</p><h2 id="四、NioEventLoop中的run方法"><a href="#四、NioEventLoop中的run方法" class="headerlink" title="四、NioEventLoop中的run方法"></a>四、NioEventLoop中的run方法</h2><p>通过<code>SingleThreadEventExecutor.this.run();</code>调用的实际上是NioEventLoop中的run方法，这个方法是NioEventLoop的核心方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.BUSY_WAIT:</span><br><span class="line">                    <span class="comment">// fall-through to SELECT since the busy-wait is not supported with NIO</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">                    select(wakenUp.getAndSet(<span class="keyword">false</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// &#x27;wakenUp.compareAndSet(false, true)&#x27; is always evaluated</span></span><br><span class="line">                    <span class="comment">// before calling &#x27;selector.wakeup()&#x27; to reduce the wake-up</span></span><br><span class="line">                    <span class="comment">// overhead. (Selector.wakeup() is an expensive operation.)</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="comment">// However, there is a race condition in this approach.</span></span><br><span class="line">                    <span class="comment">// The race condition is triggered when &#x27;wakenUp&#x27; is set to</span></span><br><span class="line">                    <span class="comment">// true too early.</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="comment">// &#x27;wakenUp&#x27; is set to true too early if:</span></span><br><span class="line">                    <span class="comment">// 1) Selector is waken up between &#x27;wakenUp.set(false)&#x27; and</span></span><br><span class="line">                    <span class="comment">//    &#x27;selector.select(...)&#x27;. (BAD)</span></span><br><span class="line">                    <span class="comment">// 2) Selector is waken up between &#x27;selector.select(...)&#x27; and</span></span><br><span class="line">                    <span class="comment">//    &#x27;if (wakenUp.get()) &#123; ... &#125;&#x27;. (OK)</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="comment">// In the first case, &#x27;wakenUp&#x27; is set to true and the</span></span><br><span class="line">                    <span class="comment">// following &#x27;selector.select(...)&#x27; will wake up immediately.</span></span><br><span class="line">                    <span class="comment">// Until &#x27;wakenUp&#x27; is set to false again in the next round,</span></span><br><span class="line">                    <span class="comment">// &#x27;wakenUp.compareAndSet(false, true)&#x27; will fail, and therefore</span></span><br><span class="line">                    <span class="comment">// any attempt to wake up the Selector will fail, too, causing</span></span><br><span class="line">                    <span class="comment">// the following &#x27;selector.select(...)&#x27; call to block</span></span><br><span class="line">                    <span class="comment">// unnecessarily.</span></span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                    <span class="comment">// To fix this problem, we wake up the selector again if wakenUp</span></span><br><span class="line">                    <span class="comment">// is true immediately after selector.select(...).</span></span><br><span class="line">                    <span class="comment">// It is inefficient in that it wakes up the selector for both</span></span><br><span class="line">                    <span class="comment">// the first case (BAD - wake-up required) and the second case</span></span><br><span class="line">                    <span class="comment">// (OK - no wake-up required).</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (wakenUp.get()) &#123;</span><br><span class="line">                        selector.wakeup();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// fall through</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cancelledKeys = <span class="number">0</span>;</span><br><span class="line">            needsToSelectAgain = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio;</span><br><span class="line">            <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">                    runAllTasks();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">                    runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleLoopException(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Always handle shutdown even if the loop processing threw an exception.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isShuttingDown()) &#123;</span><br><span class="line">                closeAll();</span><br><span class="line">                <span class="keyword">if</span> (confirmShutdown()) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleLoopException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先要介绍一下：ioRatio，NioEventLoop并不是所有的时间都在做nio相关的事情，还有提交到NioEventLoop中执行的普通任务，提交的入口就在SingleThreadEventExecutor#execute方法中，当调用这个方法之后，会将task加入到内部的一个队列中，这部分逻辑和JDK中的线程池很像，不再赘述了。</p><p>看一下addTask：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addTask</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;task&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!offerTask(task)) &#123;</span><br><span class="line">        reject(task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细看一下究竟，首先offerTask：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">offerTask</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isShutdown()) &#123;</span><br><span class="line">        reject();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> taskQueue.offer(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>taskQueue是什么呢？是SingleThreadEventExecutor构造的时候创建的，回头看一下这部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SingleThreadEventExecutor</span><span class="params">(EventExecutorGroup parent, Executor executor,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    <span class="keyword">boolean</span> addTaskWakesUp, <span class="keyword">int</span> maxPendingTasks,</span></span></span><br><span class="line"><span class="params"><span class="function">                                    RejectedExecutionHandler rejectedHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    <span class="keyword">this</span>.addTaskWakesUp = addTaskWakesUp;</span><br><span class="line">    <span class="keyword">this</span>.maxPendingTasks = Math.max(<span class="number">16</span>, maxPendingTasks);</span><br><span class="line">    <span class="keyword">this</span>.executor = ObjectUtil.checkNotNull(executor, <span class="string">&quot;executor&quot;</span>);</span><br><span class="line">    taskQueue = newTaskQueue(<span class="keyword">this</span>.maxPendingTasks);</span><br><span class="line">    rejectedExecutionHandler = ObjectUtil.checkNotNull(rejectedHandler, <span class="string">&quot;rejectedHandler&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了newTaskQueue方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Queue&lt;Runnable&gt; <span class="title">newTaskQueue</span><span class="params">(<span class="keyword">int</span> maxPendingTasks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(maxPendingTasks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建了一个LinkedBlockingQueue，到这里taskQueue是什么算是明白了，再看看reject方法：</p><p>有两个reject方法：</p><ul><li>reject()</li><li>reject(Runnable task)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">&quot;event executor terminated&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    rejectedExecutionHandler.rejected(task, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了rejectedExecutionHandler，这个rejectedExecutionHandler不知道还记不记得，在创建NioEventLoopGroup的时候就传入了这个参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler REJECT = <span class="keyword">new</span> RejectedExecutionHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejected</span><span class="params">(Runnable task, SingleThreadEventExecutor executor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里面不管是哪个reject方法，最终都是抛出了一个RejectedExecutionException异常。</p><p>到这里，addTask方法内的逻辑就看清楚了。</p><p>知道这这些，再看一下ioRatio这个参数，这个参数代表单位时间内处理nio和普通task的时间分配比率，默认是50，即用在两边的时间一样。</p><p>再仔细看看run方法内的逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</span><br><span class="line">    <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">case</span> SelectStrategy.BUSY_WAIT:</span><br><span class="line">    <span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">        select(wakenUp.getAndSet(<span class="keyword">false</span>));</span><br><span class="line">        <span class="keyword">if</span> (wakenUp.get()) &#123;</span><br><span class="line">            selector.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>calculateStrategy方法是什么呢：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSelectStrategy</span> <span class="keyword">implements</span> <span class="title">SelectStrategy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> SelectStrategy INSTANCE = <span class="keyword">new</span> DefaultSelectStrategy();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DefaultSelectStrategy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateStrategy</span><span class="params">(IntSupplier selectSupplier, <span class="keyword">boolean</span> hasTasks)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasTasks ? selectSupplier.get() : SelectStrategy.SELECT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hasTasks()方法返回taskQueue中是否有任务，如果没有任务的话，返回SelectStrategy.SELECT，那样就就会调用select(wakenUp.getAndSet(false))方法，如果任务不为空，则调用selectSupplier.get()，selectSupplier在NioEventLoop中定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> IntSupplier selectNowSupplier = <span class="keyword">new</span> IntSupplier() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> selectNow();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">selectNow</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> selector.selectNow();</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// restore wakeup state if needed</span></span><br><span class="line">         <span class="keyword">if</span> (wakenUp.get()) &#123;</span><br><span class="line">             selector.wakeup();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>get方法调用了selectNow()方法，这个方法也很简单，调用了jdk selector的selectNow方法，这个selector是在NioEventLoop构造的时候创建的。selectNow返回的值是大于等于0的，所以会跳过switch中的所有逻辑。</p><p>switch内的逻辑总结一下，如果有task，则调用selectNow并跳出switch，如果没有task，则调用select(wakenUp.getAndSet(false))。</p><p>这两条路都看一下。</p><h3 id="1-select-wakenUp-getAndSet-false"><a href="#1-select-wakenUp-getAndSet-false" class="headerlink" title="1. select(wakenUp.getAndSet(false))"></a>1. select(wakenUp.getAndSet(false))</h3><p>先说一下这个方法干了啥，这个方法其实就是NioEventLoop没事情做了，现在只能跑过来等Nio事件，并且一边等Nio事件一边还要检查taskQueue中有没有任务到来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">boolean</span> oldWakenUp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Selector selector = <span class="keyword">this</span>.selector;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> selectCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> currentTimeNanos = System.nanoTime();</span><br><span class="line">        <span class="keyword">long</span> selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">long</span> timeoutMillis = (selectDeadLineNanos - currentTimeNanos + <span class="number">500000L</span>) / <span class="number">1000000L</span>;</span><br><span class="line">            <span class="keyword">if</span> (timeoutMillis &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (selectCnt == <span class="number">0</span>) &#123;</span><br><span class="line">                    selector.selectNow();</span><br><span class="line">                    selectCnt = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hasTasks() &amp;&amp; wakenUp.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">                selector.selectNow();</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> selectedKeys = selector.select(timeoutMillis);</span><br><span class="line">            selectCnt ++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (selectedKeys != <span class="number">0</span> || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">&quot;Selector.select() returned prematurely because &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;Thread.currentThread().interrupt() was called. Use &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;NioEventLoop.shutdownGracefully() to shutdown the NioEventLoop.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> time = System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;</span><br><span class="line">                logger.warn(</span><br><span class="line">                        <span class="string">&quot;Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;.&quot;</span>,</span><br><span class="line">                        selectCnt, selector);</span><br><span class="line"></span><br><span class="line">                rebuildSelector();</span><br><span class="line">                selector = <span class="keyword">this</span>.selector;</span><br><span class="line"></span><br><span class="line">                selector.selectNow();</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            currentTimeNanos = time;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Selector.select() returned prematurely &#123;&#125; times in a row for Selector &#123;&#125;.&quot;</span>,</span><br><span class="line">                        selectCnt - <span class="number">1</span>, selector);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(CancelledKeyException.class.getSimpleName() + <span class="string">&quot; raised by a Selector &#123;&#125; - JDK bug?&quot;</span>,</span><br><span class="line">                    selector, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先算出一个selectDeadLineNanos，是由下一个定时任务的开始时间算出来的。看一下循环方法内部：</p><p>首先看一下下一个定时任务是否会在500微秒内开始，如果在接下来500微秒开始则退出循环。如果hasTask，则退出循环。然后调用<code>selector.select(timeoutMillis);</code>，这里会阻塞线程，除非有一个以上的Channel被唤醒或者时间到了，才会唤醒线程，唤醒之后又会检查hasTask和是否有Channel被唤醒（selectedKeys是否&gt;0）等检查条件。</p><p>在下面这里解决了一个bug，那就是JDK本身select被无限唤醒导致CPU空转的bug，原理是，一旦bug触发，由于selector.select这步会被一直唤醒而不会阻塞，所以selectCnt会增加的很快，并且消耗的时间将会非常的短，当在非常短的时间内，selectCnt增加到512之后，就会任务bug被触发了，因为selector.select的阻塞失效了。这时候会调用rebuildSelector()。</p><p>rebuildSelector比较简单，就是重新创建一个Selector，然后把旧的Selector中注册过的Channel重新注册到新的Selector中，然后替换掉旧的Selector就可以了，最后调用close关闭掉旧的Selector。</p><h3 id="2-当switch跳出后，就会根据ioRatio将时间分比率分配到Nio事件和Task上"><a href="#2-当switch跳出后，就会根据ioRatio将时间分比率分配到Nio事件和Task上" class="headerlink" title="2. 当switch跳出后，就会根据ioRatio将时间分比率分配到Nio事件和Task上"></a>2. 当switch跳出后，就会根据ioRatio将时间分比率分配到Nio事件和Task上</h3><p>跳出上面的select循环后，有两个重要的函数：processSelectedKeys()，runAllTasks()。分别对应nio事件处理和task任务。</p><h4 id="processSelectedKeys："><a href="#processSelectedKeys：" class="headerlink" title="processSelectedKeys："></a>processSelectedKeys：</h4><p>首先在processSelectedKeysPlain中循环遍历了所有的SelectionKey：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeysPlain</span><span class="params">(Set&lt;SelectionKey&gt; selectedKeys)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// check if the set is empty and if so just return to not create garbage by</span></span><br><span class="line">        <span class="comment">// creating a new Iterator every time even if there is nothing to process.</span></span><br><span class="line">        <span class="comment">// See https://github.com/netty/netty/issues/597</span></span><br><span class="line">        <span class="keyword">if</span> (selectedKeys.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterator&lt;SelectionKey&gt; i = selectedKeys.iterator();</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> SelectionKey k = i.next();</span><br><span class="line">            <span class="keyword">final</span> Object a = k.attachment();</span><br><span class="line">            i.remove();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) &#123;</span><br><span class="line">                processSelectedKey(k, (AbstractNioChannel) a);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;</span><br><span class="line">                processSelectedKey(k, task);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!i.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (needsToSelectAgain) &#123;</span><br><span class="line">                selectAgain();</span><br><span class="line">                selectedKeys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Create the iterator again to avoid ConcurrentModificationException</span></span><br><span class="line">                <span class="keyword">if</span> (selectedKeys.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    i = selectedKeys.iterator();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后对于每个SelectionKey调用processSelectedKey去处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();</span><br><span class="line">        <span class="keyword">if</span> (!k.isValid()) &#123;</span><br><span class="line">            <span class="keyword">final</span> EventLoop eventLoop;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                eventLoop = ch.eventLoop();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignored) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (eventLoop != <span class="keyword">this</span> || eventLoop == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            unsafe.close(unsafe.voidPromise());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> readyOps = k.readyOps();</span><br><span class="line">            <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> ops = k.interestOps();</span><br><span class="line">                ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">                k.interestOps(ops);</span><br><span class="line"></span><br><span class="line">                unsafe.finishConnect();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">                ch.unsafe().forceFlush();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">                unsafe.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException ignored) &#123;</span><br><span class="line">            unsafe.close(unsafe.voidPromise());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里，就是处理NioEvent的核心内容了，对于每个SelectionKey，都看一下有没有就绪的事件。</p><p>对于就绪的事件，会调用unsafe相应的方法，这里面会触发Netty中Pipeline中的事件链，去调用各个Handler中的处理逻辑。这部分之后会讲。</p><p>到这里就知道了，Netty的事件入口了，可以说，这里是Netty的引擎，是驱动Netty工作的核心逻辑！</p><h4 id="runAllTasks"><a href="#runAllTasks" class="headerlink" title="runAllTasks"></a>runAllTasks</h4><p>这个没什么好说的了，挨个执行taskQueue中的任务，留意一下分配的处理时间就完事了。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>NioEventLoop可以说是Netty的心脏，他驱动了各种Nio事件，并处理各种提交过来的任务。</p><p>我们一段一段的分析了NioEventLoop中的核心方法，看看它到底是如何运作的，是如何创建自己以及如何创建内部的Thread的，也看到了NioEventLoop是如何消除JDK中的bug的。</p><p>NioEventLoop的触发方式还是水平触发，和JDK是一样的。</p><p>还有一个比较重要的方法没有分析，那就是shutdownGracefully方法，里面封装了Netty著名的优雅关机逻辑，回头我们看一下这个方法。</p><p>这里只讲了事件是如何触发的，之后我们会看到事件是如何在Pipeline中的各个Handler中流动的。</p><p>希望你喜欢这篇文章~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;长文预警！！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、NioEventLoop概要&quot;&gt;&lt;a href=&quot;#一、NioEventLoop概要&quot; class=&quot;headerlink&quot; title=&quot;一、NioEventLoop概要&quot;&gt;</summary>
      
    
    
    
    <category term="Netty" scheme="https://www.jelliclecat.cn/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://www.jelliclecat.cn/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty源码-1-NioEventLoopGroup</title>
    <link href="https://www.jelliclecat.cn/articles/Netty/netty-1/"/>
    <id>https://www.jelliclecat.cn/articles/Netty/netty-1/</id>
    <published>2019-09-18T14:05:51.000Z</published>
    <updated>2021-06-25T13:47:33.057Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>建议大家手头都有一份netty的源码对照阅读。</p></blockquote><p><strong>从EchoServer入手</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> SSL = System.getProperty(<span class="string">&quot;ssl&quot;</span>) != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = Integer.parseInt(System.getProperty(<span class="string">&quot;port&quot;</span>, <span class="string">&quot;8007&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// Configure SSL.</span></span><br><span class="line">        <span class="keyword">final</span> SslContext sslCtx;</span><br><span class="line">        <span class="keyword">if</span> (SSL) &#123;</span><br><span class="line">            SelfSignedCertificate ssc = <span class="keyword">new</span> SelfSignedCertificate();</span><br><span class="line">            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sslCtx = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Configure the server.</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">final</span> EchoServerHandler serverHandler = <span class="keyword">new</span> EchoServerHandler();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">             .channel(NioServerSocketChannel.class)</span><br><span class="line">             .option(ChannelOption.SO_BACKLOG, <span class="number">100</span>)</span><br><span class="line">             .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">             .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                 <span class="meta">@Override</span></span><br><span class="line">                 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                     ChannelPipeline p = ch.pipeline();</span><br><span class="line">                     <span class="keyword">if</span> (sslCtx != <span class="keyword">null</span>) &#123;</span><br><span class="line">                         p.addLast(sslCtx.newHandler(ch.alloc()));</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span></span><br><span class="line">                     p.addLast(serverHandler);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Start the server.</span></span><br><span class="line">            ChannelFuture f = b.bind(PORT).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Wait until the server socket is closed.</span></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Shut down all event loops to terminate all threads.</span></span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SSL的部分先不管，先看看netty的服务启动过程，主要有两个重要的点：</p><ul><li>创建NioEventLoopGroup，服务端有两个，bossGroup和workerGroup</li><li>ServerBootstrap绑定端口。</li></ul><p>在创建NioEventLoopGroup的过程中，会创建NioEventLoop，这部分比较复杂需要单独写成一篇，然后创建NioEventLoopGroup的过程和创建ServerBootstrap的过程各写成一篇博客，一共用三篇博客来看netty的启动过程。</p><h2 id="创建NioEventLoopGroup"><a href="#创建NioEventLoopGroup" class="headerlink" title="创建NioEventLoopGroup"></a>创建NioEventLoopGroup</h2><p>看看创建NioEventLoopGroup的过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NioEventLoopGroup.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(nThreads, (Executor) <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(nThreads, executor, SelectorProvider.provider());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">int</span> nThreads, Executor executor, <span class="keyword">final</span> SelectorProvider selectorProvider)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(nThreads, executor, selectorProvider, DefaultSelectStrategyFactory.INSTANCE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, <span class="keyword">final</span> SelectorProvider selectorProvider, <span class="keyword">final</span> SelectStrategyFactory selectStrategyFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到如果我们没有传入线程数的话，nThreads默认为零，之后可以看到如果nThreads为零的话，会使用<code>availableProcessors() * 2</code>代替，即可用线程数的两倍。</p><h3 id="三个默认参数："><a href="#三个默认参数：" class="headerlink" title="三个默认参数："></a>三个默认参数：</h3><p>在构造方法的传递过程中，传入了几个默认参数：</p><ul><li>SelectorProvider.provider()</li><li>DefaultSelectStrategyFactory.INSTANCE</li><li>RejectedExecutionHandlers.reject()</li></ul><p>稍微点进去看一下这几个类是干什么的：</p><p>SelectorProvider负责打开一个Selector，这是java nio中的原生Selector。</p><p>DefaultSelectStrategyFactory.INSTANCE是一个SelectStrategy的工厂实例，返回的是DefaultSelectStrategy.INSTANCE，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSelectStrategyFactory</span> <span class="keyword">implements</span> <span class="title">SelectStrategyFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SelectStrategyFactory INSTANCE = <span class="keyword">new</span> DefaultSelectStrategyFactory();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DefaultSelectStrategyFactory</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SelectStrategy <span class="title">newSelectStrategy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DefaultSelectStrategy.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSelectStrategy</span> <span class="keyword">implements</span> <span class="title">SelectStrategy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> SelectStrategy INSTANCE = <span class="keyword">new</span> DefaultSelectStrategy();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DefaultSelectStrategy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateStrategy</span><span class="params">(IntSupplier selectSupplier, <span class="keyword">boolean</span> hasTasks)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasTasks ? selectSupplier.get() : SelectStrategy.SELECT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SelectStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicates a blocking select should follow.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> SELECT = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicates the IO loop should be retried, no blocking select to follow directly.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> CONTINUE = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicates the IO loop to poll for new events without blocking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> BUSY_WAIT = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The &#123;<span class="doctag">@link</span> SelectStrategy&#125; can be used to steer the outcome of a potential select</span></span><br><span class="line"><span class="comment">     * call.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> selectSupplier The supplier with the result of a select result.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hasTasks true if tasks are waiting to be processed.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> #SELECT&#125; if the next step should be blocking select &#123;<span class="doctag">@link</span> #CONTINUE&#125; if</span></span><br><span class="line"><span class="comment">     *         the next step should be to not select but rather jump back to the IO loop and try</span></span><br><span class="line"><span class="comment">     *         again. Any value &gt;= 0 is treated as an indicator that work needs to be done.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculateStrategy</span><span class="params">(IntSupplier selectSupplier, <span class="keyword">boolean</span> hasTasks)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类具体干嘛用的之后会看到，<strong>现在不用纠结。</strong></p><p>RejectedExecutionHandlers.reject()返回的也是一个单例的RejectedExecutionHandler()，这个类是一个拒绝策略，熟悉线程池的同学都知道。这个类简单的抛出一个异常RejectedExecutionException。</p><p>最后，NioEventLoopGroup中的构造函数调用了父类MultithreadEventLoopGroup的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MultithreadEventLoopGroup.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以看到，如果nThreads为0的话，使用DEFAULT_EVENT_LOOP_THREADS代替，也就是<code>availableProcessors() * 2</code>。这里又调用了父类MultithreadEventExecutorGroup的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MultithreadEventExecutorGroup.java</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(nThreads, executor, DefaultEventExecutorChooserFactory.INSTANCE, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="真正的构造函数："><a href="#真正的构造函数：" class="headerlink" title="真正的构造函数："></a>真正的构造函数：</h3><p>最终委托给了真正的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nThreads &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">&quot;nThreads: %d (expected: &gt; 0)&quot;</span>, nThreads));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> ThreadPerTaskExecutor(newDefaultThreadFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    children = <span class="keyword">new</span> EventExecutor[nThreads];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i ++) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            children[i] = newChild(executor, args);</span><br><span class="line">            success = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Think about if this is a good exception type</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;failed to create a child event loop&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                    children[j].shutdownGracefully();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                    EventExecutor e = children[j];</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">while</span> (!e.isTerminated()) &#123;</span><br><span class="line">                            e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException interrupted) &#123;</span><br><span class="line">                        <span class="comment">// Let the caller handle the interruption.</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    chooser = chooserFactory.newChooser(children);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> FutureListener&lt;Object&gt; terminationListener = <span class="keyword">new</span> FutureListener&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Object&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (terminatedChildren.incrementAndGet() == children.length) &#123;</span><br><span class="line">                terminationFuture.setSuccess(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (EventExecutor e: children) &#123;</span><br><span class="line">        e.terminationFuture().addListener(terminationListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;EventExecutor&gt; childrenSet = <span class="keyword">new</span> LinkedHashSet&lt;EventExecutor&gt;(children.length);</span><br><span class="line">    Collections.addAll(childrenSet, children);</span><br><span class="line">    readonlyChildren = Collections.unmodifiableSet(childrenSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MultithreadEventExecutorGroup持有一个<code>EventExecutor[] children</code>，是真正执行任务的线程，ExecutorGroup可以看做一个线程容器，负责管理持有的EventExecutor。这里可以对照java原生的线程池，EventExecutorGroup可以看做ExecutorService，EventExecutor可以看做线程池中的Thread，不过是升级版的。</p><p><strong>这个构造函数主要干了三件事情：</strong></p><h4 id="1-创建executor"><a href="#1-创建executor" class="headerlink" title="1. 创建executor"></a>1. 创建executor</h4><p>看这个构造函数，如果executor是null（这个例子中就是null，可以回顾一下之前的构造函数，第二个构造函数就传入了一个null的executor），就new了一个ThreadPerTaskExecutor，这个ThreadPerTaskExecutor对于每个提交的任务（顾名思义，Thread Per Task），都使用ThreadFactory创建一个新的Thread去 执行这个任务。关键是ThreadFactory，是使用newDefaultThreadFactory()获得的，newDefaultThreadFactory方法创建了一个DefaultThreadFactory，DefaultThreadFactory除了定制了Thread的名字之类的属性外，最重要的是他返回的是FastThreadLocalThread类型的Thread，FastThreadLocalThread里面使用的ThreadLocal是FastThreadLocal，并将任务Runnable包装成一个新的Runable：<code>FastThreadLocalRunnable.wrap(r)</code>。</p><p>所以这个executor的逻辑是对于每个新的任务，都创建一个FastThreadLocalThread类型的线程去执行这个任务。</p><p>netty中所有的线程都是使用FastThreadLocalThread+FastThreadLocal这样的搭配，原因是FastThreadLocal比java原生的ThreadLocal要快，并且杜绝了原生ThreadLocal潜在的内存泄漏，这部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">// MultithreadEventExecutorGroup的构造函数</span></span><br><span class="line">        <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            executor = <span class="keyword">new</span> ThreadPerTaskExecutor(newDefaultThreadFactory());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ThreadFactory <span class="title">newDefaultThreadFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultThreadFactory(getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// netty的默认ThreadFactory，创建出来的Thread是FastThreadLocalThread</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ... 省略</span></span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t = newThread(FastThreadLocalRunnable.wrap(r), prefix + nextId.incrementAndGet());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (t.isDaemon() != daemon) &#123;</span><br><span class="line">                t.setDaemon(daemon);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t.getPriority() != priority) &#123;</span><br><span class="line">                t.setPriority(priority);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">            <span class="comment">// Doesn&#x27;t matter even if failed to set.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Thread <span class="title">newThread</span><span class="params">(Runnable r, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FastThreadLocalThread(threadGroup, r, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个简单的Executor，对于每个新的任务都创建一个新的线程去执行任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory threadFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPerTaskExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (threadFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;threadFactory&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        threadFactory.newThread(command).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// netty中的runable都被包装成这个，目的是在run方法执行完后，主动调用FastThreadLocal.removeAll();</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FastThreadLocalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable runnable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FastThreadLocalRunnable</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.runnable = ObjectUtil.checkNotNull(runnable, <span class="string">&quot;runnable&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            runnable.run();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 手动清理这ThreadLocal，防止内存泄漏</span></span><br><span class="line">            FastThreadLocal.removeAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Runnable <span class="title">wrap</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> runnable <span class="keyword">instanceof</span> FastThreadLocalRunnable ? runnable : <span class="keyword">new</span> FastThreadLocalRunnable(runnable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里不讲FastThreadLocalThread和FastThreadLocal的代码。</p><h4 id="2-创建所有的children"><a href="#2-创建所有的children" class="headerlink" title="2. 创建所有的children"></a>2. 创建所有的children</h4><p>好了，接下来就是其创建children，每一个children都是一个NioEventLoop，看一下这个类：</p><p><img src="https://raw.githubusercontent.com/zhengrenjie/PicGo/master/img/1572922852536.jpg"></p><p>这个类是一个SingleThreadEventLoop，简而言之就是一个单线程的线程池。这个类非常复杂，之后再看这个类，现在只用知道，EventExecutorGroup现在初始化了一个NioEventLoop数组并持有。</p><h4 id="3-创建chooser"><a href="#3-创建chooser" class="headerlink" title="3. 创建chooser"></a>3. 创建chooser</h4><p>先看一下chooser是什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnstableApi</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EventExecutorChooserFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a new &#123;<span class="doctag">@link</span> EventExecutorChooser&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">EventExecutorChooser <span class="title">newChooser</span><span class="params">(EventExecutor[] executors)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Chooses the next &#123;<span class="doctag">@link</span> EventExecutor&#125; to use.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@UnstableApi</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">EventExecutorChooser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns the new &#123;<span class="doctag">@link</span> EventExecutor&#125; to use.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function">EventExecutor <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先传入了一个EventExecutor[]，然后又一个next方法用来从EventExecutor[]中选出一个EventExecutor。这里的EventExecutor就是NioEventLoop。</p><p>构造函数中使用的EventExecutorChooserFactory是DefaultEventExecutorChooserFactory.INSTANCE：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnstableApi</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultEventExecutorChooserFactory</span> <span class="keyword">implements</span> <span class="title">EventExecutorChooserFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DefaultEventExecutorChooserFactory INSTANCE = <span class="keyword">new</span> DefaultEventExecutorChooserFactory();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DefaultEventExecutorChooserFactory</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EventExecutorChooser <span class="title">newChooser</span><span class="params">(EventExecutor[] executors)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isPowerOfTwo(executors.length)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PowerOfTwoEventExecutorChooser(executors);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> GenericEventExecutorChooser(executors);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (val &amp; -val) == val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerOfTwoEventExecutorChooser</span> <span class="keyword">implements</span> <span class="title">EventExecutorChooser</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger idx = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> EventExecutor[] executors;</span><br><span class="line"></span><br><span class="line">        PowerOfTwoEventExecutorChooser(EventExecutor[] executors) &#123;</span><br><span class="line">            <span class="keyword">this</span>.executors = executors;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> EventExecutor <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> executors[idx.getAndIncrement() &amp; executors.length - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericEventExecutorChooser</span> <span class="keyword">implements</span> <span class="title">EventExecutorChooser</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger idx = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> EventExecutor[] executors;</span><br><span class="line"></span><br><span class="line">        GenericEventExecutorChooser(EventExecutor[] executors) &#123;</span><br><span class="line">            <span class="keyword">this</span>.executors = executors;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> EventExecutor <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> executors[Math.abs(idx.getAndIncrement() % executors.length)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终创建了PowerOfTwoEventExecutorChooser或者GenericEventExecutorChooser作为chooser。这里可以看出，如果传给chooser的EventExecutor数组是2的整数幂，那么next方法的执行效率会快很多。</p><p>这里有一个快速判断是个数是否是2的整数次幂的方法，学习到了吗，这里使用到了补码的性质。</p><h2 id="Q-amp-A以及总结"><a href="#Q-amp-A以及总结" class="headerlink" title="Q&amp;A以及总结"></a>Q&amp;A以及总结</h2><p>Q：NioEventLoopGroup是什么？</p><p>A：netty内部的线程池，用来管理netty内部的线程。</p><p>Q：NioEventLoop是什么？</p><p>A：包装了一个Thread，NioEventLoop本质是一个只有一个线程的线程池，但是比起线程池来说干了很多其他的事情，比如注册一些事件，注册Selector等功能。</p><p>Q：NioEventLoopGroup如何选出一个NioEventLoop？</p><p>A：使用chooser，chooser有两种，当NioEventLoop数量是2的整数幂的时候，使用与运算，否则使用取余从数组中取出NioEventLoop，但是两种方法都是轮询的取，去的顺序没有区别，只是前者更快。</p><p>Q：Thread和FastThreadLocalThread的区别？</p><p>A：FastThreadLocalThread使用的是FastThreadLocal，FastThreadLocal内部是线性的存取数据，而java原生的ThreadLocal使用的是hash，所以FastThreadLocal要快不少。FastThreadLocalThread中跑的Runnable是经过包装后的FastThreadLocalRunnable，在执行完run方法后，会主动清除FastThreadLocal中的数据。</p><p>Q：NioEventLoopGroup的创建过程是怎样的？</p><p>A：首先创建executor，最主要的作用是使用netty的ThreadFactory，保证创建的线程都是FastThreadLocalThread，然后根据nThread创建NioEventLoop数组，作为children持有，最后根据children创建一个chooser。</p><p>Q：NioEventLoopGroup持有的children是什么？</p><p>A：就是一个NioEventLoop数组，用来真正干活的线程组。</p><p>Q：bossGroup和workerGroup的区别：</p><p>A：bossGroup用来监听客户端连接请求，连接之后就将其他的任务交给workerGroup了，所以bossGroup内部只有一个线程，workerGroup的默认大小是<code>availableProcessors() * 2</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;建议大家手头都有一份netty的源码对照阅读。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;从EchoServer入手&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t</summary>
      
    
    
    
    <category term="Netty" scheme="https://www.jelliclecat.cn/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://www.jelliclecat.cn/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>从零手撸一个Rpc框架-4-Registry层、Config层</title>
    <link href="https://www.jelliclecat.cn/articles/Rpc/MyRpc-4/"/>
    <id>https://www.jelliclecat.cn/articles/Rpc/MyRpc-4/</id>
    <published>2019-09-12T12:12:34.000Z</published>
    <updated>2021-06-25T13:47:33.059Z</updated>
    
    <content type="html"><![CDATA[<p>上篇我们讲了重构后的transport层和Cluster层，这篇博客讲一讲Registry层和Config层，Registry层使用了Zookeeper的实现。</p><p>GitHub项目地址：<a href="https://github.com/zhengrenjie/susu">susu</a></p><p>话不多说，我们直接开始看吧~</p><h2 id="一、Registry层"><a href="#一、Registry层" class="headerlink" title="一、Registry层"></a>一、Registry层</h2><p>registry层有两个基本接口：Registry和NotifyListener。</p><h3 id="1-Registry"><a href="#1-Registry" class="headerlink" title="1. Registry"></a>1. Registry</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Registry</span> <span class="keyword">extends</span> <span class="title">LifeCircle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(URL url)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unregister</span><span class="params">(URL url)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(URL url, NotifyListener listener)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">(URL url, NotifyListener listener)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-NotifyListener"><a href="#2-NotifyListener" class="headerlink" title="2. NotifyListener"></a>2. NotifyListener</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NotifyListener</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">(URL registryUrl, List&lt;URL&gt; urls)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>功能非常的明显。这里url作为统一的配置总线很让人疑惑，需要好好分析一下不同的方法传入的URL参数有什么不同：</p><p>调用register，一般来说是Server端调用的，Server端将所有的东西都准备好之后，将自己的URL注册到注册中心中，URL中至少需要包含一下内容：</p><ul><li>服务的名称，即暴露的接口名，这个接口名字是包含包名全路径的。</li><li>服务所属的组，以后随着暴露出的接口越来越多，不同工程或者不同业务所暴露出来的接口需要分组管理。</li><li>服务版本，表示当前服务所提供的版本，客户端需要根据版本信息判断该服务能否提供服务。</li><li>URL中需要标识该URL是属于服务端的URL还是客户端的URL。</li><li>服务协议，客户端需要判断协议是否匹配</li><li>最后，需要该服务的ip地址和端口号。</li></ul><p>调用subscribe，一般来说subscribe是client端调用的，用来订阅一个目录，那这里传入的URL是什么呢？是服务端的URL吗？我要订阅一个服务，那我传入一个服务端的URL，听起来没错，但是细想是有问题的，第一，客户端调用这个方法怎么知道服务端的url呢？第二，这里订阅一个目录需要URL吗？其实不需要，只需要目录名就行。那么问题来了，client端怎么获得目录名呢？</p><p>这里需要先明确一下注册中心的目录结构，从上面Server端url的结构可以看出一些端倪，服务端目录结构至少由这几个层次：服务组，服务接口名（interface name），服务ip&amp;port。</p><blockquote><p>/ [server group] / [interface name] / [ip&amp;port&amp;settings]</p></blockquote><p>那么client端需要订阅的其实只有服务组和服务名就可以了，上篇博客已经先简单的分析过URL的结构了，一组对应的Client和Server的URL都是有相同的服务接口名称的，这是必须的，服务接口名就是我们定义的服务接口的全路径名称。所以Client端是可以轻松拿到这两个字段的，至于组，直接在URL中设置就行了。</p><p>这么看来调用subscribe的时候，传入的url是客户端自己的url，然后程序根据client端的url订阅到具体的目录下。</p><p>这么看来，调用subscribe貌似没必要传入URL这种包含这么多信息的对象，只需要传入组名和服务名就可以了，这样的话程序逻辑就非常清晰了。但是dubbo除了单单subscribe以外，还干了一件事，就是同时将client端的url注册到了另一个目录下，这样做的目的我估计是两点：一，方便监控Client端的在线信息；二，Server端以至于其他任何终端，都可以发现Client端并主动与Client端通信。</p><p>好了，到这里就介绍完了Registry中两个主要的方法（register和subscribe）以及他们的参数URL需要怎么传。</p><p>在subscribe方法中还会传一个回调，这个回调就是NotifyListener，用来当订阅的节点目录发生变化时，通知这个NotifyListener，可以想象到，实现这个NotifyListener的类，需要能够知道服务端暴露信息的节点的变化，并拿到变化后的服务端的全量url，从而更新自己的服务列表，对了，有这个需求的对象就是Cluster，很明显Cluster需要知道服务端的变化，并动态更新自己的Invoker可用列表，加入新的可以用的服务并销毁不再可用的服务。</p><p>看了上篇博客的朋友们肯定知道，Cluster是继承了NotifyListener接口的。</p><p>这里有个小问题：这里发生了反向依赖，即cluster层依赖了更高层registry层的接口NotifyListener，但是NotifyListener接口其实可以不属于registry层，可以作为core层的基础接口，这样就解决了反向依赖的问题，但是还是有点不和谐，如果你们有更好的建议，可以给我留言或者提PR。</p><h3 id="3-ZookeeperRegistry"><a href="#3-ZookeeperRegistry" class="headerlink" title="3. ZookeeperRegistry"></a>3. ZookeeperRegistry</h3><p>这个类实现了Zookeeper版本的注册中心的实现。</p><p>先贴一下目录：</p><blockquote><p> / [server group] / [interface name] / [ip&amp;port&amp;settings]</p></blockquote><p>常用的Zookeeper有两种：zkClient和Curator，客户端有一些好处，它封装了Zookeeper的原生api，提供了更加方便的接口，并在内部做了一些重连重试等功能的封装。</p><p>dubbo将zookeeper的实现也进行了抽象，分别支持了不同的Zookeeper客户端，并可可以配置。motan就更加直接一些，直接使用了zkClient。我使用的是Curator。</p><p>在看这段代码之前，大家可能需要先熟悉一下zookeeper的使用和Curator的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZookeeperRegistry</span> <span class="keyword">implements</span> <span class="title">Registry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PROVIDERS = <span class="string">&quot;providers&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONSUMERS = <span class="string">&quot;consumers&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;CuratorEventType&gt; interested = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 只关心创建节点和删除节点</span></span><br><span class="line">    interested.add(CuratorEventType.CREATE);</span><br><span class="line">    interested.add(CuratorEventType.DELETE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> URL registryUrl;</span><br><span class="line">  <span class="keyword">private</span> CuratorFramework client;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ZookeeperRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    registryUrl = url;</span><br><span class="line">    init();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// todo: RetryPolicy 支持配置</span></span><br><span class="line">    RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">// todo : 账号密码支持</span></span><br><span class="line">    client = CuratorFrameworkFactory.builder()</span><br><span class="line">        .connectString(registryUrl.getIpPortString())</span><br><span class="line">        .sessionTimeoutMs(<span class="number">10000</span>)</span><br><span class="line">        .retryPolicy(retryPolicy)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    client.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (client != <span class="keyword">null</span>) &#123;</span><br><span class="line">      client.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (client == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    CuratorFrameworkState state = client.getState();</span><br><span class="line">    <span class="keyword">return</span> state == CuratorFrameworkState.STARTED;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    checkClientStatus();</span><br><span class="line">    String path = buildPath(url);</span><br><span class="line">    <span class="keyword">if</span> (!exist(path)) &#123;</span><br><span class="line">      buildPath(path);</span><br><span class="line">    &#125;</span><br><span class="line">    path += SusuConstants.PATH_SEP + encodeUrl(url.getUrlString());</span><br><span class="line">    ephemeralPath(path);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    checkClientStatus();</span><br><span class="line">    String path = buildPath(url) + SusuConstants.PATH_SEP + url.getUrlString();</span><br><span class="line">    delete(path);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(URL url, NotifyListener listener)</span> </span>&#123;</span><br><span class="line">    checkClientStatus();</span><br><span class="line">    String path = buildServerPath(url);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先同步的回调一次</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      List&lt;String&gt; urls = client.getChildren().forPath(buildServerPath(url) + SusuConstants.PATH_SEP + PROVIDERS);</span><br><span class="line">      listener.notify(<span class="keyword">this</span>.registryUrl, urls.stream()</span><br><span class="line">          .map(<span class="keyword">this</span>::decodeUrl)</span><br><span class="line">          .map(URL::parse)</span><br><span class="line">          .collect(Collectors.toList()));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RegistryException(<span class="string">&quot;ZookeeperRegistry: getChildren error&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册监听器</span></span><br><span class="line">    CuratorListener curatorListener = ((client0, event) -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (interested.contains(event.getType())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (event.getPath() != <span class="keyword">null</span> &amp;&amp; event.getPath().startsWith(path)) &#123;</span><br><span class="line">          System.out.println(event);<span class="comment">// todo: 调试删除</span></span><br><span class="line">          List&lt;String&gt; urls = event.getChildren();</span><br><span class="line">          listener.notify(<span class="keyword">this</span>.registryUrl, urls.stream()</span><br><span class="line">              .map(<span class="keyword">this</span>::decodeUrl)</span><br><span class="line">              .map(URL::parse)</span><br><span class="line">              .collect(Collectors.toList()));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    client.getCuratorListenable().addListener(curatorListener);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkClientStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isAvailable()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RegistryException(</span><br><span class="line">          <span class="string">&quot;ZookeeperRegistry: registry unavailable, url: &quot;</span> + registryUrl.getIpPortString());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">buildPath</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    String root = url.getString(URL_CONFIG.ROOT);</span><br><span class="line">    String group = url.getString(URL_CONFIG.GROUP);</span><br><span class="line">    String path = url.getPath();</span><br><span class="line">    String serverOrClient = url.getBoolean(URL_CONFIG.IS_SERVER) ? PROVIDERS : CONSUMERS;</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">        + SusuConstants.PATH_SEP + group</span><br><span class="line">        + SusuConstants.PATH_SEP + path</span><br><span class="line">        + SusuConstants.PATH_SEP + serverOrClient;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  ... <span class="comment">// 略，具体代码见github</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们实现了LifeCircle中的三个方法，实现了registry的初始化，状态检查以及销毁，后面展示了两个主要方法的实现。</p><h4 id="register方法"><a href="#register方法" class="headerlink" title="register方法"></a>register方法</h4><p>首先做一下状态检查，然后检查服务路径是否存在，如果不存在这个服务的路径，则先创建一个永久服务路径，即：</p><blockquote><p> / [server group] / [interface name]</p></blockquote><p>然后创建一个临时路径保存当前的url信息。这里要用临时节点，因为不是每次服务退出的时候都能保证去手动清理掉自己在注册中心注册的服务信息，比如服务突然断线，这样就没有时间让服务自己清理，这时候如果这个节点是永久节点，那客户端就会拿到一个已经下线的服务的url，从而造成服务失败。zookeeper可以在断线后自动清理掉临时节点。</p><p>本地测试，注册服务之前和注册之后：</p><p><img src="https://raw.githubusercontent.com/zhengrenjie/PicGo/master/img/WeChat105369b9243d9186746559c590d5a7e3.png" alt="注册服务之前和注册之后"></p><p>服务root是/susu，组名是default，服务名是com.nowcoder.first.IService，ip&amp;port&amp;setting是下面经过编码后的url。</p><h4 id="subscribe方法"><a href="#subscribe方法" class="headerlink" title="subscribe方法"></a>subscribe方法</h4><p>subscribe方法比较简单，首先将目录下的所有url读出来先回调一次NotifyListener，保证在调用subscribe方法的时候可以同步获取数据。然后通过Curator注册了一个zookeeper的watcher，用来通知NotifyListener节点的变化。</p><p>这里我们只关心两个事件：节点create和delete信息。注意这里订阅的节点层级，不能多不能少，不然获得的回调信息会有问题。</p><p>回调事件触发的时候，我们还需要检查触发的节点路径是否是和当前监听的Url想匹配的服务，如果不是将会忽略。</p><p>后面的几个方法register和unsubscribe等就不赘述了。</p><h2 id="二、Config层"><a href="#二、Config层" class="headerlink" title="二、Config层"></a>二、Config层</h2><p>config层太简单了，暂时还没啥好些的，嘻嘻~之后再补充吧。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>这波代码更新一共2200行，应该说还是加了不少东西。</p><p>问题也有很多，目前大多数优化和修改都是在Client这边，Server那边仍然是最蠢的代码实现，比如多个服务同时暴露在同一个端口时如何路由等功能都还没有。</p><p>URL这个东西也是很闹心，感觉这个东西相当于传了一个map，一个map在一个框架里面从头到脚的作为一个参数去传太难受了，这个问题我要想办法解决一下。</p><p>日志目前还是一片空白，也还没有做。</p><p>Filter也还没有支持，没有想到要支持哪些东西，因为东西都太杂了太小了，没有大的功能需要支持了。</p><p>还有一个挺重要的，对Object的各种方法需要处理一下。</p><p>我想把URL、Config以及服务端的路由功能做了之后先测试一波，看看有没有明显的问题再说吧~</p><p>如果你有好的建议欢迎提出来~</p><p>BTW，SPI这个东西暂时没有支持的打算了，感觉暂时不需要。</p><p>GitHub项目地址：<a href="https://github.com/zhengrenjie/susu">susu</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上篇我们讲了重构后的transport层和Cluster层，这篇博客讲一讲Registry层和Config层，Registry层使用了Zookeeper的实现。&lt;/p&gt;
&lt;p&gt;GitHub项目地址：&lt;a href=&quot;https://github.com/zhengrenji</summary>
      
    
    
    
    <category term="Rpc" scheme="https://www.jelliclecat.cn/categories/Rpc/"/>
    
    
    <category term="Rpc" scheme="https://www.jelliclecat.cn/tags/Rpc/"/>
    
  </entry>
  
  <entry>
    <title>从零手撸一个Rpc框架-3-Cluster层、代码重构</title>
    <link href="https://www.jelliclecat.cn/articles/Rpc/MyRpc-3/"/>
    <id>https://www.jelliclecat.cn/articles/Rpc/MyRpc-3/</id>
    <published>2019-09-11T13:20:50.000Z</published>
    <updated>2021-06-25T13:47:33.048Z</updated>
    
    <content type="html"><![CDATA[<p>GitHub项目地址：<a href="https://github.com/zhengrenjie/susu">susu</a></p><p>之前我们可以说是直接了当的实现了传输层（netty）、编码层（susu协议）、代理层（动态代理），完成了一个rpc框架所需的最少代码，上次代码一共800多行，可以说非常“mini”了。</p><p>先看看上次遗留的一个小问题：demo中的client需要sleep一下，我们只用把NettyClient#open方法稍微修改一下就行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    ChannelFuture future = bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">20880</span>).sync();</span><br><span class="line">    clientChannel = future.channel();</span><br><span class="line">    clientChannel.closeFuture().sync();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为：</span></span><br><span class="line">ChannelFuture future = bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">20880</span>).sync();</span><br><span class="line">clientChannel = future.channel();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    clientChannel.closeFuture().sync();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p>我们只用把connect操作从线程里面拿出来即可，这样在open方法退出时，可以保证client已经连上server了。当然，我现在对这部分逻辑进行了更加细致的操作，不再是new Thread了，请看最新代码：</p><p><a href="https://github.com/zhengrenjie/susu">susu</a></p><p>这次更新，我加入了对zookeeper的支持，使用zookeeper做注册中心，做了服务注册和发现，并将项目做了分层和抽象，初步完成了配置层，以及最后同样写了一个例子，一起来看看吧~</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>我们的mini版代码中，代码是严重耦合的，这里不再细致的探讨设计模式的思想，之后会专门写一篇博客探讨设计模式的思想。这里我们使用抽象和分层去解决耦合的问题，保证层与层之间单向依赖，并保证这种依赖是建立在接口上的，而不是实现上的。</p><p>之前的代码没有做任何可用性扩展，这里我定义了几个自定义异常去包装各种异常信息，并抽象出了一个LifeCircle接口，用来管理所有对象的生命周期。在dubbo和motan中，这个接口的名称是Node，也是用来管理生命周期的。</p><p>之前的代码客户端和服务端是直连的，没有配置，没有服务注册发现，也没有服务簇，这次通过加入Config层、Registry层、Cluster层开始着手去处理这些问题。</p><h2 id="一、项目分模块"><a href="#一、项目分模块" class="headerlink" title="一、项目分模块"></a>一、项目分模块</h2><p>目前susu项目分为5层，每层之间单向依赖，从下到上依次是：</p><ul><li><strong>susu-core</strong>：核心模块，定义了一些基本接口、常量、异常、工具类以及一些基础类。</li><li><strong>susu-transport</strong>：传输层，定义了传输层的接口、netty版本的实现以及编解码层的实现。这里将codec层和transport层合并了，因为这两层本质上都属于传输层的逻辑，之后如果需要独立出编解码层可以考虑拆开。</li><li><strong>susu-cluster</strong>：服务簇，包装了传输层，管理传输层的生命周期，并完成了负载均衡功能。</li><li><strong>susu-registry</strong>：注册层，定义了基本的注册接口，并实现zookeeper版本的注册中心。</li><li><strong>susu-config</strong>：总设置层，定义了服务暴露和服务发现的接口和功能实现，是rpc框架的总入口。</li></ul><p>对比与dubbo和motan的层次接口（系列博客第一篇有讲），我这里层次更少一些，原因目前还不需要这么多层。</p><p>接下来一层一层看吧，core模块不单独讲，因为各层都会或多或少的使用到core中的代码，所以我们直接从传输层开始看，看看在上篇博客的基础上，做了哪些改进。</p><p>在介绍具体代码之前我要先说一些我的设计思想：所有的设计均基于实际需求，而不是形式上的设计。</p><p>【<strong>插播！</strong>】这里我分享一个我自己的小经验：多数的设计是基于已有的架构遇到问题后在解决的过程中设计并完善的，所有的设计都不是无的放矢的。我自己最开始想去写一些抽象的接口的时候就会犯难，因为总是想着先去抽象一个什么什么接口再去实现，而结果往往是无从下手，不妨换一个思路，先去实现功能而不管实现的过程有多蠢，然后再review代码考虑该怎么优化以及抽象，由于你自己实现了一遍功能，在实现的过程中就能感受到哪些地方是可能重用的，可以抽出来甚至抽象成一个接口，所以这时候抽象出来的接口是真正基于功能抽象出来的。所有的抽象都应该基于功能而不是想象，想象出来的抽象往往很多地方是和实际功能相冲突的。当然，除了那些一眼就知道要怎么抽象的接口可以直接写之外。这里是有实际依据的，我看了spring1.0版的代码，那时候还不叫spring，叫interface21，然后也看了spring5.0的代码，发现很多抽象层次和接口是后来才扩展出来的，这说明是在开发过程中，发现有些地方可以或者说需要抽象成一个接口，然后再进行抽象的，而不是在spring最初版本就把所有的接口定义好了的。但随着接口和抽象的越来越熟练，在设计的时候就就可以提前写好很多的接口了，这时候的设计可能才开始从上到下设计，但在没<strong>那么的</strong>熟练之前，还是可以考虑由下到上的设计方式。</p><h2 id="二、susu-transport"><a href="#二、susu-transport" class="headerlink" title="二、susu-transport"></a>二、susu-transport</h2><p>我们需要思考一个问题，传输层其实是可能会需要支持不同的协议的，这里的传输层不等于七层网络中的传输层，这里的传输层单指网络传输，里面可能会包含一些应用层的协议，例如http等。所以我们需要抽象出一个传输层的api。传输层需要考虑到连接是否可用等可用性问题，所以需要进行生命周期管理。</p><h3 id="1-Channel"><a href="#1-Channel" class="headerlink" title="1. Channel"></a>1. Channel</h3><p>传输层说白了是管理端到端的连接用的，所以传输层的最基础的api应该是一个信道（或者说连接也行，后文使用信道这个词，代表客户端到服务端的一个通信通道），我们需要知道该信道是否打开或者关闭，需要有打开信道和关闭信道的方法，需要知道该信道上使用的编码协议，以及对于该信道的各种设置。我们就有下面所示的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Channel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 使用在该信道上的编解码协议</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Codec <span class="title">getCodec</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 该传输层的设置</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">URL <span class="title">getUrl</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isOpened</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isClosed</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 打开信道</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 关闭信道</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Codec接口在上篇博客介绍过了，里面有两个方法，编码和解码，这里再稍微回顾一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">  <span class="keyword">byte</span>[] encode(Object message) <span class="keyword">throws</span> CodecException;</span><br><span class="line">  <span class="function">Object <span class="title">decode</span><span class="params">(<span class="keyword">byte</span>[] data)</span> <span class="keyword">throws</span> CodecException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Client-amp-Server"><a href="#2-Client-amp-Server" class="headerlink" title="2. Client&amp;Server"></a>2. Client&amp;Server</h3><p>在Channel接口之后，我们需要分为客户端信道和服务端信道，客户端操作信道和服务端操作信道应该是有区别的，比如客户端需要有从信道发送信息给服务端并获得回复的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Client</span> <span class="keyword">extends</span> <span class="title">Channel</span> </span>&#123;</span><br><span class="line">  <span class="function">Response <span class="title">invoke</span><span class="params">(Request request)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Server</span> <span class="keyword">extends</span> <span class="title">Channel</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>严格来说，Channel需要有读写信息的接口，这也是是一个信道的基础功能之一，实际上Dubbo就是这样抽象的，但是这里考虑到Server端不会主动推送信息给Client端，所以虽然我们使用的C/S模式，但实际是B/S模式，所以这里在Client中扩展了一个类似HttpServlet中的方法，Server接口中不具有任何读写的功能。</strong>再一个，我们需要考虑到读写功能是否需要提供给上层使用，这里的结论是上层不需要调用这么具体的读写功能，上层只需要调用<code>Response invoke(Request request)</code>对于我们的rpc框架来说已经足够了（目前足够）。</p><p>这里对比一下dubbo的设计（为了缩短篇幅我把注释都删了，dubbo命名没的说，不用注释也能看懂）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Channel</span> <span class="keyword">extends</span> <span class="title">Endpoint</span> </span>&#123;</span><br><span class="line">    <span class="function">InetSocketAddress <span class="title">getRemoteAddress</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasAttribute</span><span class="params">(String key)</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">getAttribute</span><span class="params">(String key)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String key, Object value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(String key)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Endpoint</span> </span>&#123;</span><br><span class="line">    <span class="function">URL <span class="title">getUrl</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ChannelHandler <span class="title">getChannelHandler</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">InetSocketAddress <span class="title">getLocalAddress</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(Object message, <span class="keyword">boolean</span> sent)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startClose</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isClosed</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在分享一下motan的Channel设计：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Channel</span> </span>&#123;</span><br><span class="line">    <span class="function">InetSocketAddress <span class="title">getLocalAddress</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">InetSocketAddress <span class="title">getRemoteAddress</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Response <span class="title">request</span><span class="params">(Request request)</span> <span class="keyword">throws</span> TransportException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isClosed</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">URL <span class="title">getUrl</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>    InetSocketAddress getLocalAddress();    InetSocketAddress getRemoteAddress();</code>motan中的这两个方法全项目没有任何地方用到，虽然看起来是两个Channel需要有的基本功能，但是可能根本用不到，这就是我上面说的要面向功能抽象。所以我自己的Channel中，稍微精炼了一下，剔除了没有用的方法。</p><p><strong>这里有一个设计小细节</strong>：当我们在接口中定义一个方法是否需要抛出异常时，所有RuntimeException只需要以注释的形式写明即可，如果显示的抛出一个RuntimeException我个人感觉是很奇怪的，显示抛出异常的用意是告诉调用方需要显示catch，而显示catch的异常通常是Exception异常而非RuntimeException，如果说既需要显示catch，又要定义为RuntimeException异常，那本身就是矛盾的。</p><p>dubbo中就有这个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Invoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里的RpcException就是一个RuntimeException，但是却显示的抛出了。</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * invoke.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看看jdk中的做法，拿Future接口的get方法举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Waits if necessary for the computation to complete, and then</span></span><br><span class="line"><span class="comment"> * retrieves its result.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the computed result</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> CancellationException if the computation was cancelled</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ExecutionException if the computation threw an</span></span><br><span class="line"><span class="comment"> * exception</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException if the current thread was interrupted</span></span><br><span class="line"><span class="comment"> * while waiting</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br></pre></td></tr></table></figure><p>这个方法会主动抛出三个异常，不出意外的，InterruptedException和ExecutionException都是Exception类型，而CancellationException是RuntimeException类型。</p><p>这是一个小细节，不知道是我自己的理解有问题还是dubbo有他自己的用意。否则的话，RuntimeException我建议写在方法注释里面。</p><h3 id="3-AbstractEndpoint-amp-AbstractClient-amp-AbstractServer"><a href="#3-AbstractEndpoint-amp-AbstractClient-amp-AbstractServer" class="headerlink" title="3. AbstractEndpoint&amp;AbstractClient&amp;AbstractServer"></a>3. AbstractEndpoint&amp;AbstractClient&amp;AbstractServer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractEndpoint</span> <span class="keyword">implements</span> <span class="title">Channel</span>, <span class="title">Codec</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNKNOWN = -<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OPEN = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLOSE = <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> Codec codec;</span><br><span class="line">  <span class="keyword">private</span> URL url;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> CHANNEL_STATUS = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">AbstractEndpoint</span><span class="params">(Codec codec, URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.codec = codec;</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Codec <span class="title">getCodec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> codec;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> URL <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUrl</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpened</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CHANNEL_STATUS == OPEN;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isClosed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> CHANNEL_STATUS == CLOSE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CHANNEL_STATUS = OPEN;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CHANNEL_STATUS = CLOSE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">byte</span>[] encode(Object message) <span class="keyword">throws</span> CodecException &#123;</span><br><span class="line">    <span class="keyword">return</span> codec.encode(message);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(<span class="keyword">byte</span>[] data)</span> <span class="keyword">throws</span> CodecException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> codec.decode(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>封装了状态的迁移，并代理了Codec的功能，让其子类可以直接具有编解码的功能。</p><p>AbstractClient&amp;AbstractServer这两个类没有做更多的事情，继承了AbstractEndpoint并分别实现了Client接口和Server接口，AbstractClient保存了当前的任务和ResponseFuture的map。</p><p>里面比较重要的是支持了URL设置，URL在susu中承担的是配置总线的角色，不难想到AbstractClient&amp;AbstractServer的继承者中的各种配置信息都可以在URL中拿到。dubbo和motan也是用URL作为配置总线，后面我们会详细讨论URL这个类，这个类还是存在一些争议的，有一些坏味道。</p><h3 id="4-NettyClient-amp-NettyServer"><a href="#4-NettyClient-amp-NettyServer" class="headerlink" title="4. NettyClient&amp;NettyServer"></a>4. NettyClient&amp;NettyServer</h3><p>分别继承于AbstractClient&amp;AbstractServer，里面实现了Channel中定义的open方法和close方法，close方法中完成了netty的优雅关机，以及做了一些异常处理工作。</p><p>NettyChannelHandler不出意外的被我们拆开成了两个内部类：ServerChannelHandler和ClientChannelHandler，分别存在于NettyServer和NettyClient中，其逻辑没有改变，跟上篇博客中介绍的一样。</p><p>好了，transport中的抽象就写到这里啦，总结一下就是，首先进行了抽象，然后完善了信道生命周期的管理。</p><h2 id="三、susu-cluster"><a href="#三、susu-cluster" class="headerlink" title="三、susu-cluster"></a>三、susu-cluster</h2><p>从这层开始往上可以算作是服务治理的功能范畴了，首先要介绍的是配置总线URL以及对它设计的一些讨论，然后会简单介绍一些负载均衡算法，以后会开一篇博客写一写常用的静态负载均衡算法以及动态负载均衡算法，这里实现了最简单的一种：随机负载均衡，之后会逐渐完善各种负载均衡算法。</p><h3 id="1-URL"><a href="#1-URL" class="headerlink" title="1. URL"></a>1. URL</h3><p>url作为贯穿各层的配置总线的角色存在：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URL</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 协议</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> String protocol;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * host地址</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> String host;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 服务端口</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 任务路径，等同于interfaceName</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 通用设置</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, String&gt; parameters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的方法没有展示出来，但是从他的属性就能看出一些。对于rpc框架来说，其处理的对象本身就是各种各样的终端，客户端、服务端、注册中心、配置中心、监控中心等等，这些不同的终端无一不是依靠网络通信，既然是网络通信，就一定可以使用URL去描述一个网络资源。所以在RPC框架中使用URL作为一个终端的配置总线是水到渠成的事情，URL中封装了终端的协议类型，ip地址，服务端口，资源路径，以及各种自定义参数。</p><p>但这里面存在着坏味道—— URL太泛了，理解门槛较高，并有误用的风险，后面再讲config层的时候我们可以看到一些使用URL作为配置总线的问题，这里先看cluster中的内容。</p><h3 id="2-LifeCircle"><a href="#2-LifeCircle" class="headerlink" title="2. LifeCircle"></a>2. LifeCircle</h3><p>服务治理层有自己的控制生命周期的接口：LifeCircle。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifeCircle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有与资源有关的接口都应该继承这个接口。</p><h3 id="3-Invoker"><a href="#3-Invoker" class="headerlink" title="3. Invoker"></a>3. Invoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Invoker</span> <span class="keyword">extends</span> <span class="title">LifeCircle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> URL <span class="title">getURL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Response <span class="title">invoke</span><span class="params">(Request request)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Invoker是上层对于底层一次RPC调用的抽象，其实现类用于管理底层（传输层）的实例。</p><p>一个Invoker代表一个可以调用的Channel。dubbo和motan都有自己的Invoker：</p><p>dubbo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Invoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get service interface.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> service interface.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * invoke.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RpcException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Result <span class="title">invoke</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面说过，Node的作用等同于LifeCircle，这里面的Invocation等同于我们的Request，Result等同于Response。</p><p>motan中没有Invoker接口，但有一个类似功能的Caller接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Caller</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Class&lt;T&gt; <span class="title">getInterface</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Response <span class="title">call</span><span class="params">(Request request)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到除了名称不一样以外，其他的设计基本一样。</p><h3 id="4-LoadBalance"><a href="#4-LoadBalance" class="headerlink" title="4. LoadBalance"></a>4. LoadBalance</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadBalance</span> </span>&#123;</span><br><span class="line">  <span class="function">Invoker <span class="title">select</span><span class="params">(List&lt;Invoker&gt; invokers)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomLoadBalance</span> <span class="keyword">implements</span> <span class="title">LoadBalance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Random random;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">RandomLoadBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.random = <span class="keyword">new</span> Random();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Invoker <span class="title">select</span><span class="params">(List&lt;Invoker&gt; invokers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(invokers.size() == <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> invokers.get(random.nextInt(invokers.size()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常简单的lb以及它的实现类，作用就是从一组可选的Invoker中，根据一定的算法挑选出这一次调用需要使用的Invoker。刚刚说了，Invoker是对一个Channel的封装，更准确的说是对Client的封装，所以一个Invoker在这里可以等同于一个Client来理解。一个Client对应的是一个Server，所以不同的Invoker实际上对应的是不同的Server，所以使用不同的Invoker其实就是将这次请求打到不同的Server，这也是负载均衡这个概念的核心。</p><h3 id="5-DefaultInvoker"><a href="#5-DefaultInvoker" class="headerlink" title="5. DefaultInvoker"></a>5. DefaultInvoker</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultInvoker</span> <span class="keyword">implements</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Client client;</span><br><span class="line">  <span class="keyword">private</span> URL url;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DefaultInvoker</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">    Codec codec;</span><br><span class="line">    <span class="comment">// 检测传输层和编码层各用什么样的实现，如果没有使用默认实现代替</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;netty&quot;</span>.equals(url.getString(URL_CONFIG.TRANSPORT))) &#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="string">&quot;susu&quot;</span>.equals(url.getString(URL_CONFIG.CODEC))) &#123;</span><br><span class="line">        codec = <span class="keyword">new</span> SusuCodec();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        codec = <span class="keyword">new</span> SusuCodec();</span><br><span class="line">      &#125;</span><br><span class="line">      client = <span class="keyword">new</span> NettyClient(codec, url);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      client = <span class="keyword">new</span> NettyClient(<span class="keyword">new</span> SusuCodec(), url);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Response <span class="title">invoke</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先进行最简单的实现</span></span><br><span class="line">    <span class="keyword">return</span> client.invoke(request);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> URL <span class="title">getURL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    client.open();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    client.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> client.isOpened();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DefaultInvoker是invoker的默认实现，里面根据URL中的配置决定使用什么样的传输层实现，我们默认使用SusuCodec和Netty的实现。</p><h3 id="6-DefaultCluster"><a href="#6-DefaultCluster" class="headerlink" title="6. DefaultCluster"></a>6. DefaultCluster</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultCluster</span> <span class="keyword">implements</span> <span class="title">Cluster</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> LoadBalance loadBalance;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Invoker&gt; invokers;</span><br><span class="line">  <span class="keyword">private</span> List&lt;URL&gt; urls;</span><br><span class="line">  <span class="keyword">private</span> URL url;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 没有传入urls, 会去registry中拿地址</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DefaultCluster</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DefaultCluster</span><span class="params">(URL url, List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.urls = urls;</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Response <span class="title">invoke</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!init) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> SusuException(<span class="string">&quot;DefaultCluster: status error when invoke(), init: &quot;</span> + init);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(invokers == <span class="keyword">null</span> || invokers.size() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> SusuException(<span class="string">&quot;DefaultCluster: invokers is empty&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Invoker invoker = loadBalance.select(invokers);</span><br><span class="line">    <span class="keyword">if</span>(!invoker.isAvailable()) &#123;</span><br><span class="line">      invoker.init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> invoker.invoke(request);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化负载均衡策略</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;random&quot;</span>.equals(url.getString(URL_CONFIG.LOAD_BALANCE))) &#123;</span><br><span class="line">      loadBalance = <span class="keyword">new</span> RandomLoadBalance();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      loadBalance = <span class="keyword">new</span> RandomLoadBalance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据urls构建invoker</span></span><br><span class="line">    <span class="keyword">if</span>(urls != <span class="keyword">null</span> &amp;&amp; urls.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      invokers = urls.stream().map(<span class="keyword">this</span>::getInvokerFromUrl).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line">    init = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Invoker invoker : invokers) &#123;</span><br><span class="line">      <span class="keyword">if</span>(invoker.isAvailable()) &#123;</span><br><span class="line">        invoker.destroy();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    init = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(URL registryUrl, List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.urls = urls;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建Invoker的逻辑先独立出来再说，之后可能会有很复杂的创建逻辑。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Invoker <span class="title">getInvokerFromUrl</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultInvoker(url);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>持有lb的实现，以及Invoker的列表，Cluster本身也继承了Invoker接口，因为Cluster本身是一种特殊的Invoker，Cluster对于上层来说也是一个Invoker，只不过里面封装了一些请求过滤和负载均衡的工作，对于上层来说，Cluster和Invoker干的活是一样的，都是发起一次请求，获得一个返回。</p><p>Cluster管理了不同的Invoker的生命周期，并且使用了懒连接的方式：只有当一个Invoker真正被lb选中时才建立真正的连接。这样对于一致性哈希这样的负载均衡算法来说可以节约大量的连接资源—— 因为一致性哈希在原链接不出问题的情况下，永远会使用同一个连接，也就是同一个Invoker。</p><p>当上层像调用Invoker一样调用Cluster的invoke方法时，Cluster会先使用持有的lb从备选的Invoker组中选出一个，然后再进行真正的请求。</p><p>notify方法之后将Registry层的时候再细讲。</p><p>好了，Cluster层到这里也讲完啦~我实现了一个非常简单的Cluster层，我们来回顾一下Cluster层干了什么：首先使用Invoker去抽象底层的Channel，然后向上提供一个特殊的Invoker—— 一个Cluster去调用，Cluster会持有一个Invoker列表，一个Invoker映射一个Server，然后Cluster会根据负载均衡算法去调用真正的Invoker，将请求打到对应的Server上。</p><h2 id="四、Registry层、Config层"><a href="#四、Registry层、Config层" class="headerlink" title="四、Registry层、Config层"></a>四、Registry层、Config层</h2><p>由于篇幅的关系，Registry层、Config层下篇博客再讲啦~</p><p>总结一下，这篇博客讲了如何在上篇博客基本实现功能了的基础上，进行抽象、分层、扩展。可以看到，基于URL配置的方式可以在不同层非常方便是使用不同的策略去初始不同的实现，比如lb、codec、client、server。虽然每层接口我们都只提供了一种实现，但是扩展起来可以想象到会非常的方便，你甚至可以使用不同的client和server的传输层实现rpc，但是codec必须一样哦！</p><p>本篇博客还讲了Channel和Cluster的接口是如何实现以及如何设计的，这两个接口分别对应transport层和cluster层的最高抽象接口。</p><p>LifeCircle的接口做了简单介绍，但是实现没有细讲，因为这部分看代码就好了。</p><p>下篇博客我会详细介绍Registry层、Config层，当然重点是Registry层。</p><p>最新项目地址：<a href="https://github.com/zhengrenjie/susu">susu</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;GitHub项目地址：&lt;a href=&quot;https://github.com/zhengrenjie/susu&quot;&gt;susu&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之前我们可以说是直接了当的实现了传输层（netty）、编码层（susu协议）、代理层（动态代理），完成了一个rpc框架所需的最少</summary>
      
    
    
    
    <category term="Rpc" scheme="https://www.jelliclecat.cn/categories/Rpc/"/>
    
    
    <category term="Rpc" scheme="https://www.jelliclecat.cn/tags/Rpc/"/>
    
  </entry>
  
  <entry>
    <title>从零手撸一个Rpc框架-2-传输层、编码层、代理层</title>
    <link href="https://www.jelliclecat.cn/articles/Rpc/MyRpc-2/"/>
    <id>https://www.jelliclecat.cn/articles/Rpc/MyRpc-2/</id>
    <published>2019-09-07T13:20:50.000Z</published>
    <updated>2021-06-25T13:47:33.047Z</updated>
    
    <content type="html"><![CDATA[<p>这里我完成了最初始的Config层，Proxy层，Codec层，以及Transport层。</p><p>具体来说，我使用Netty作为Transport层，并进行了半包和粘包的处理；我自己定义了自己的通信协议：susu协议，协议头待会会介绍；使用Java原生的动态代理作为Proxy；Config层只写了最基础的代码。</p><p>GitHub项目地址：<a href="https://github.com/zhengrenjie/susu">susu</a></p><p>这篇博客干货比较多，基本都是代码，前方高能：</p><h2 id="一、测试程序"><a href="#一、测试程序" class="headerlink" title="一、测试程序"></a>一、测试程序</h2><p>Rpc服务接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IService</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">say</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Client代码（也叫consumer）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Reference&lt;IService&gt; reference = <span class="keyword">new</span> Reference&lt;&gt;();</span><br><span class="line">    reference.setInterfaceClass(IService.class);</span><br><span class="line">    IService service = reference.getRefer();</span><br><span class="line">    <span class="comment">// Thread.sleep(1000);</span></span><br><span class="line">    String result = service.say(<span class="string">&quot;zrj&quot;</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Server代码（也叫Provider）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Exporter&lt;IService&gt; exporter = <span class="keyword">new</span> Exporter&lt;&gt;();</span><br><span class="line">    exporter.setInterfaceClazz(IService.class);</span><br><span class="line">    exporter.setRef(<span class="keyword">new</span> IServiceImpl());</span><br><span class="line">    exporter.export();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IServiceImpl</span> <span class="keyword">implements</span> <span class="title">IService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;from rpc &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分代码上篇博客最后已经介绍过了，这篇博客将底层的实现全部完成了，运行结果如下：</p><p><img src="https://raw.githubusercontent.com/zhengrenjie/PicGo/master/img/20190907141608.png"></p><h2 id="二、代码细节"><a href="#二、代码细节" class="headerlink" title="二、代码细节"></a>二、代码细节</h2><p>我先介绍两个类：Request和Response，这两个类封装了通信payload中的所有信息，我们的Rpc框架使用这两个类进行网络的信息交换，之后也会基于这两个类做序列化等工作。</p><h4 id="Request："><a href="#Request：" class="headerlink" title="Request："></a>Request：</h4><p>各个字段的说明写在注释里面了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每次请求唯一的id</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> requestId;</span><br><span class="line">  <span class="comment">// 服务的接口名称，带包名</span></span><br><span class="line">  <span class="keyword">private</span> String interfaceName;</span><br><span class="line">  <span class="comment">// 方法名</span></span><br><span class="line">  <span class="keyword">private</span> String methodName;</span><br><span class="line">  <span class="comment">// 参数列表的类型，用英文逗号分隔，名称带包名</span></span><br><span class="line">  <span class="keyword">private</span> String argsType;</span><br><span class="line">  <span class="comment">// 参数列表对应的参数值，会被序列化</span></span><br><span class="line">  <span class="keyword">private</span> Object[] argsValue;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* getter &amp; setter */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Response："><a href="#Response：" class="headerlink" title="Response："></a>Response：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对应的是那个请求的id</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> requestId;</span><br><span class="line">  <span class="comment">// 返回值</span></span><br><span class="line">  <span class="keyword">private</span> Object returnValue;</span><br><span class="line">  <span class="comment">// 抛出了异常</span></span><br><span class="line">  <span class="keyword">private</span> Exception exception;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* getter &amp; setter */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1、服务端："><a href="#1、服务端：" class="headerlink" title="1、服务端："></a>1、服务端：</h3><h4 id="Exporter："><a href="#Exporter：" class="headerlink" title="Exporter："></a>Exporter：</h4><p>Exporter代码超简单，调用export时直接打开了一个NettyServer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exporter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> T ref;</span><br><span class="line">  <span class="keyword">private</span> Class&lt;T&gt; interfaceClazz;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInterfaceClazz</span><span class="params">(Class&lt;T&gt; interfaceClazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.interfaceClazz = interfaceClazz;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRef</span><span class="params">(T ref)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.ref = ref;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">export</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NettyServer nettyServer = <span class="keyword">new</span> NettyServer(<span class="keyword">new</span> Provider&lt;&gt;(ref, interfaceClazz));</span><br><span class="line">    nettyServer.open();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面引入了两个个新的类：NettyServer、Provider，我们先看NettyServer。</p><h4 id="NettyServer："><a href="#NettyServer：" class="headerlink" title="NettyServer："></a>NettyServer：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> <span class="keyword">extends</span> <span class="title">ChannelDuplexHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Handler handler;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">    NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">    ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">    serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">        .channel(NioServerSocketChannel.class)</span><br><span class="line">        .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            pipeline.addLast(<span class="string">&quot;decoder&quot;</span>, <span class="keyword">new</span> NettyDecoder());</span><br><span class="line">            pipeline.addLast(<span class="string">&quot;encoder&quot;</span>, <span class="keyword">new</span> NettyEncoder());</span><br><span class="line">            NettyChannelHandler channelHandler = <span class="keyword">new</span> NettyChannelHandler(handler);</span><br><span class="line">            pipeline.addLast(<span class="string">&quot;handler&quot;</span>, channelHandler);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    serverBootstrap.childOption(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>);</span><br><span class="line">    serverBootstrap.childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ChannelFuture f = serverBootstrap.bind(<span class="number">20880</span>);</span><br><span class="line">      f.syncUninterruptibly();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个最基本的Netty服务，里面接受一个参数：handler，这是一个通用接口，用来处理具体逻辑，当NettyServer接受到请求后，最终的处理逻辑会委托给handler。</p><h4 id="Handler："><a href="#Handler：" class="headerlink" title="Handler："></a>Handler：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传输层获得数据后，交给具体的处理方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zrj</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">  <span class="function">Object <span class="title">handle</span><span class="params">(Object message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NettyServer代码中出现了几个新类：NettyDecoder、NettyEncoder、NettyChannelHandler，这里先简单介绍一下：NettyDecoder用来解决半包粘包问题，NettyEncoder没什么用，NettyChannelHandler是一个标准的Netty的ChannelHandler，用来处理各种网络事件，待会会仔细的看这几个类，现在先简单介绍一下有个印象。</p><p>当我们创建完NettyServer后，会启动20880接口去监听服务并阻塞等待。</p><h4 id="NettyChannelHandler："><a href="#NettyChannelHandler：" class="headerlink" title="NettyChannelHandler："></a>NettyChannelHandler：</h4><p>这个类是一个标准的ChannelHandler类，用来处理网络事件，Client端和Server端共用这个类，之后如果Client端和Server端的代码差异增加，这个类可以拆开成两个ChannelHandler，分别用于Client端和Server端，这里我偷懒就直接写成一个了，继承了ChannelDuplexHandler，这里我们先看怎么处理Request的部分逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyChannelHandler</span> <span class="keyword">extends</span> <span class="title">ChannelDuplexHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Codec codec;</span><br><span class="line">  <span class="keyword">private</span> Handler handler;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">NettyChannelHandler</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.codec = <span class="keyword">new</span> SusuCodec();</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">    Object object = codec.decode((<span class="keyword">byte</span>[]) msg);</span><br><span class="line">    <span class="keyword">if</span> (!(object <span class="keyword">instanceof</span> Request) &amp;&amp; !(object <span class="keyword">instanceof</span> Response)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> SusuException(<span class="string">&quot;NettyChannelHandler: unsupported message type when encode: &quot;</span> + object.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Request) &#123;</span><br><span class="line">      processRequest(ctx, (Request) object);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      processResponse(ctx, (Response) object);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(ChannelHandlerContext ctx, Request msg)</span> </span>&#123;</span><br><span class="line">    Object result = handler.handle(msg);</span><br><span class="line">    Response response = <span class="keyword">new</span> Response();</span><br><span class="line">    response.setRequestId(msg.getRequestId());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(result <span class="keyword">instanceof</span> Exception) &#123;</span><br><span class="line">      response.setException((Exception) result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      response.setReturnValue(result);</span><br><span class="line">    &#125;</span><br><span class="line">    sendResponse(ctx, response);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processResponse</span><span class="params">(ChannelHandlerContext ctx, Response msg)</span> </span>&#123;</span><br><span class="line">    handler.handle(msg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">sendResponse</span><span class="params">(ChannelHandlerContext ctx, Response response)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] msg = codec.encode(response);</span><br><span class="line">    <span class="keyword">if</span> (ctx.channel().isActive()) &#123;</span><br><span class="line">      <span class="keyword">return</span> ctx.channel().writeAndFlush(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，当我们收到msg后，直接调用了Codec进行解码，这里msg一定是byte[]，这一点是由NettyDecoder保证的，之后在讲半包粘包问题时会介绍到这部分代码。</p><p>解码之后，如果是Request，则委托给handler去执行具体的代码，这里的Handle是我们创建NettyServer的时候传进来的，是一个Provider实例，下面会介绍Provider。Provider返回给我们一个结果，我们先判断结果是否是一个异常，并创建一个Response填充具体的字段，最后我们使用sendResponse方法将这个Response返回给客户端，当然返回之前还是要先编码为byte[]。</p><p>到这里，一个完整的过程已经很清晰了，我们剩下需要关心的是两件事情，一个是如何编解码，一个是Provider具体干了什么，编解码对于这部分逻辑是透明的，你只用知道byte[]被转换成了Request或者Response就可以了，所以编解码部分最后再讲。</p><p>下面我们看看Provider。</p><h4 id="Provider："><a href="#Provider：" class="headerlink" title="Provider："></a>Provider：</h4><p>可以看到，在我们创建NettyServer的时候传入了一个Provider实例，这个实例实现了Handler接口，看看里面干了什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zrj CreateDate: 2019/9/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> Map&lt;String, Method&gt; methodMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> T ref;</span><br><span class="line">  <span class="keyword">private</span> Class&lt;T&gt; interfaceClazz;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 找到所有interfaceClazz可以调用的方法，并缓存下来，缓存名字要保留参数类型的完整名称，防止函数重载</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Provider</span><span class="params">(T ref, Class&lt;T&gt; interfaceClazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!interfaceClazz.isInterface()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> SusuException(<span class="string">&quot;Provider: interfaceClazz is not a interface!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.ref = ref;</span><br><span class="line">    <span class="keyword">this</span>.interfaceClazz = interfaceClazz;</span><br><span class="line">    List&lt;Method&gt; methods = ReflectUtils.parseMethod(interfaceClazz);</span><br><span class="line">    <span class="keyword">for</span>(Method method : methods) &#123;</span><br><span class="line">      String methodDesc = ReflectUtils.getMethodDesc(method);</span><br><span class="line">      methodMap.putIfAbsent(methodDesc, method);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">handle</span><span class="params">(Object message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(message <span class="keyword">instanceof</span> Request)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> SusuException(<span class="string">&quot;Provider: handle unsupported message type: &quot;</span> + message.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    Request request = (Request) message;</span><br><span class="line">    String methodName = ReflectUtils.getMethodDesc(request.getMethodName(), request.getArgsType());</span><br><span class="line">    Method method = methodMap.get(methodName);</span><br><span class="line">    <span class="keyword">if</span>(method == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SusuException(<span class="string">&quot;Provider: can&#x27;t find method: &quot;</span> + methodName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> method.invoke(ref, request.getArgsValue());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SusuException(<span class="string">&quot;Provider: exception when invoke method: &quot;</span> + methodName, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Error e) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SusuException(<span class="string">&quot;Provider: error when invoke method: &quot;</span> + methodName, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，构造函数中，首先找到了interfaceClazz的所有可以被调用的Method对象，这里只保留了限定符为public的方法，并将这些方法全部缓存到本地，Key用的是方法签名，方法签名包括参数列表，防止有重载的方法。</p><p>当调用handler的时候，将message转成Request类型（这个在调用方保证），然后拿到Request中的调用的方法和参数信息组装成Key，通过Key拿到对应的Methed，然后通过反射调用具体的方法，最后返回调用的结果，如果调用出错则抛出异常。</p><p>好了，到这里看看我们完成了什么功能，首先我们使用Netty开了一个端口监听请求，请求到来之后经过最后扔进了Provider中调用具体的方法，并返回调用结果。</p><p>当然，Netty传过来的数据是二进制数据，需要反序列化。</p><p>其实服务端的代码到这里就介绍完了，是不是很简单！</p><p>回顾一下主要是三个类，</p><ul><li>NettyServer，用来启动一个Netty服务监听网络。</li><li>NettyChannelHandler，用来接收网络请求，并将二进制请求反序列化为Request对象，然后调用Provider获取结果，包装成Response返回给客户端。</li><li>Provider，持有服务接口的实现的引用，并使用反射解析服务接口的各种方法，当Request对象到来时，根据Request中的信息得到具体需要调用的方法，使用反射调用后获取结果，返回给NettyChannelHandler。</li></ul><p>好了服务端的代码先到这，接下来看看客户端的代码，客户端也就是Rpc的调用方。</p><h3 id="2、客户端"><a href="#2、客户端" class="headerlink" title="2、客户端"></a>2、客户端</h3><h4 id="Reference："><a href="#Reference：" class="headerlink" title="Reference："></a>Reference：</h4><p>Reference也很简单，使用默认的ProxyFactory创建一个代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reference</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ProxyFactory&lt;T&gt; proxyFactory;</span><br><span class="line">  <span class="keyword">private</span> Class&lt;T&gt; interfaceClass;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Reference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.proxyFactory = <span class="keyword">new</span> ProxyFactory&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getRefer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> proxyFactory.getProxy(interfaceClass);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getInterfaceClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> interfaceClass;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInterfaceClass</span><span class="params">(Class&lt;T&gt; interfaceClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.interfaceClass = interfaceClass;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ProxyFactory："><a href="#ProxyFactory：" class="headerlink" title="ProxyFactory："></a>ProxyFactory：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(clazz.getClassLoader(), <span class="keyword">new</span> Class[]&#123;clazz&#125;, <span class="keyword">new</span> ProxyHandler());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建了一个代理，重点在于ProxyHandler，看看ProxyHandler干了什么。</p><h4 id="ProxyHandler："><a href="#ProxyHandler：" class="headerlink" title="ProxyHandler："></a>ProxyHandler：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> NettyClient client;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ProxyHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.client = <span class="keyword">new</span> NettyClient();</span><br><span class="line">    client.open();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">    Request request = <span class="keyword">new</span> Request();</span><br><span class="line">    request.setInterfaceName(method.getDeclaringClass().getName());</span><br><span class="line">    request.setMethodName(method.getName());</span><br><span class="line">    request.setArgsType(getArgsTypeString(args));</span><br><span class="line">    request.setArgsValue(args);</span><br><span class="line">    Response response = client.invoke(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(response.getException() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> response.getException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response.getReturnValue();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">getArgsTypeString</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(args.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(Object object : args) &#123;</span><br><span class="line">      sb.append(object.getClass().getName()).append(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sb.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      sb.setLength(sb.length() - <span class="string">&quot;,&quot;</span>.length());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见这个类是整个客户端的重点，首先，ProxyHandler构造时，首先创建了一个NettyClient并持有。当代理类的方法被调用的时候，首先根据调用的运行时信息创建Request，然后调用<code>Response response = client.invoke(request)</code>获取Response，然后返回具体的结果，抛出异常或者正常返回。</p><p>具体的调用工作交给了NettyClient。</p><h4 id="NettyClient："><a href="#NettyClient：" class="headerlink" title="NettyClient："></a>NettyClient：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> io.netty.channel.Channel clientChannel;</span><br><span class="line">  <span class="keyword">private</span> Codec codec = <span class="keyword">new</span> SusuCodec();</span><br><span class="line">  <span class="keyword">private</span> Map&lt;Long, ResponseFuture&gt; currentTask = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Response <span class="title">invoke</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] msg = codec.encode(request);</span><br><span class="line">    ResponseFuture response = <span class="keyword">new</span> DefaultResponseFuture();</span><br><span class="line">    currentTask.put(request.getRequestId(), response);</span><br><span class="line">    clientChannel.writeAndFlush(msg);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (Response) response.getValue();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      Response response1 = <span class="keyword">new</span> Response();</span><br><span class="line">      response1.setRequestId(request.getRequestId());</span><br><span class="line">      response1.setException(<span class="keyword">new</span> TransportException(<span class="string">&quot;NettyClient: response.getValue interrupted!&quot;</span>));</span><br><span class="line">      <span class="keyword">return</span> response1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">    NioEventLoopGroup nioEventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">    bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">1000</span>);</span><br><span class="line">    bootstrap.option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>);</span><br><span class="line">    bootstrap.option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>);</span><br><span class="line">    bootstrap.group(nioEventLoopGroup)</span><br><span class="line">        .channel(NioSocketChannel.class)</span><br><span class="line">        .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                     ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                     pipeline.addLast(<span class="string">&quot;decoder&quot;</span>, <span class="keyword">new</span> NettyDecoder());</span><br><span class="line">                     pipeline.addLast(<span class="string">&quot;encoder&quot;</span>, <span class="keyword">new</span> NettyEncoder());</span><br><span class="line">                     pipeline.addLast(<span class="string">&quot;handler&quot;</span>, <span class="keyword">new</span> NettyChannelHandler(</span><br><span class="line">                         message -&gt; &#123;</span><br><span class="line">                           Response response = (Response) message;</span><br><span class="line">                           ResponseFuture future = currentTask.remove(response.getRequestId());</span><br><span class="line">                           future.onSuccess(response);</span><br><span class="line">                           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                         &#125;</span><br><span class="line">                     ));</span><br><span class="line">                   &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        ChannelFuture future = bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">20880</span>).sync();</span><br><span class="line">        clientChannel = future.channel();</span><br><span class="line">        clientChannel.closeFuture().sync();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用open之后，同样很简单的创建了一个Netty客户端，不过这里<code> bootstrap.connect(&quot;127.0.0.1&quot;, 20880).sync();</code>方法在另外一个线程中调用，不然会阻塞我们的Main方法，之后的代码无法运行。</p><p>在里面创建客户端时，同样加入了NettyDecoder，NettyEncoder，NettyChannelHandler以及一个匿名的Handler，这个Handler用来通知ResponseFuture，服务端已经返回结果了。</p><p>ResponseFuture是一个Future，用来异步获取Netty服务返回的结果。</p><h4 id="ResponseFuture："><a href="#ResponseFuture：" class="headerlink" title="ResponseFuture："></a>ResponseFuture：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultResponseFuture</span> <span class="keyword">implements</span> <span class="title">ResponseFuture</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SUCCESS = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCEL = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FAILED = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> status;</span><br><span class="line">  <span class="keyword">private</span> Response value;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DefaultResponseFuture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.status = NEW;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Response response)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">      value = response;</span><br><span class="line">      status = SUCCESS;</span><br><span class="line">      lock.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Response response)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">      value = response;</span><br><span class="line">      status = FAILED;</span><br><span class="line">      lock.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (status &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">      <span class="keyword">if</span> (status &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">      &#125;</span><br><span class="line">      lock.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，当我们调用getValue()方法时，如果结果还没有准备好，会挂起当前调用的线程，直到onSuccess方法被调用，设置进来结果后，才会唤醒所有等待的线程。onSuccess方法刚刚已经看到了，这个方法被注册进了NettyChannelHandler，当Netty服务端返回时，onSuccess就会被回调。</p><p>最后看看NettyClient中的invoke方法，这个方法超级简单，首先序列化Request请求，然后创建一个DefaultResponseFuture用来异步获取结果， 并将当前的请求放入本地的缓存中，方便异步返回时配对，然后调用<code>clientChannel.writeAndFlush(msg);</code>，将请求发给服务端，最后调用DefaultResponseFuture.getValue阻塞等待结果。</p><h3 id="3、编解码，susu协议"><a href="#3、编解码，susu协议" class="headerlink" title="3、编解码，susu协议"></a>3、编解码，susu协议</h3><p>编解码器的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 编解码器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zrj CreateDate: 2019/9/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">  <span class="keyword">byte</span>[] encode(Object message) <span class="keyword">throws</span> CodecException;</span><br><span class="line">  <span class="function">Object <span class="title">decode</span><span class="params">(<span class="keyword">byte</span>[] data)</span> <span class="keyword">throws</span> CodecException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>susu协议编解码器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 编解码核心类：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 协议头：</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * |      magic 16bit     | version 8bit | type flag 8bit |</span></span><br><span class="line"><span class="comment"> * |               content length 32 bit                  |</span></span><br><span class="line"><span class="comment"> * |               request id     64 bit                  |</span></span><br><span class="line"><span class="comment"> * |               request id     64 bit                  |</span></span><br><span class="line"><span class="comment"> * |               content ...                            |</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zrj CreateDate: 2019/9/5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SusuCodec</span> <span class="keyword">implements</span> <span class="title">Codec</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>不用多解释了，协议头写在注释里面啦！</p><p>至于具体的编解码过程没什么好说的，就是硬编码，感兴趣的朋友们看Github上的源码，GitHub项目地址：<a href="https://github.com/zhengrenjie/susu">susu</a>。</p><p>除了协议头之外，还有对Request和Response对象的序列化，我使用的是FastJson序列化框架：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FastJsonSerialization</span> <span class="keyword">implements</span> <span class="title">Serialization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object object) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    SerializeWriter out = <span class="keyword">new</span> SerializeWriter();</span><br><span class="line">    JSONSerializer serializer = <span class="keyword">new</span> JSONSerializer(out);</span><br><span class="line">    serializer.config(SerializerFeature.WriteEnumUsingToString, <span class="keyword">true</span>);</span><br><span class="line">    serializer.config(SerializerFeature.WriteClassName, <span class="keyword">true</span>);</span><br><span class="line">    serializer.write(object);</span><br><span class="line">    <span class="keyword">return</span> out.toBytes(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialize</span><span class="params">(<span class="keyword">byte</span>[] bytes, Class&lt;T&gt; clazz)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> JSON.parseObject(<span class="keyword">new</span> String(bytes), clazz);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、半包与粘包"><a href="#4、半包与粘包" class="headerlink" title="4、半包与粘包"></a>4、半包与粘包</h3><p>半包与粘包发生在TCP传输中，由于TCP是面向流的协议，TCP本身不知道如何去截断有完整语义的数据包，所以在客户端看来是分离的单独语义的数据包经过TCP传输后可能有的数据包被截断了，有的数据包被连在一起了，这是需要我们自己设计协议去解析数据流，将我们自己定义的数据包从TCP流中识别出来。</p><p>最常用的方法就是在我们自定义的协议头中加入content length字段，标识这段数据包有多少数据。</p><p>在netty中，netty提供了方便的用于处理半包粘包问题的入口。</p><p>我们可以继承ByteToMessageDecoder，每次轮询到TCP中有未读数据后，会调用decode方法，decode方法会让你有机会先”检视“一次数据，如果数据不完整（发生了半包）的话，就直接return，等待TCP的下次轮询，当有足够的数据之后，我们可以根据自己的规则，将数据写入到List&lt;Object&gt; out参数中，告诉netty我们有足够的数据了，可以继续进行下面的步骤了。</p><h4 id="NettyDecoder："><a href="#NettyDecoder：" class="headerlink" title="NettyDecoder："></a>NettyDecoder：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 数据比协议头小，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (in.readableBytes() &lt;= CodecConstants.HEADER_SIZE) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标记初始位置</span></span><br><span class="line">    in.markReaderIndex();</span><br><span class="line">    <span class="keyword">short</span> magic = in.readShort();</span><br><span class="line">    <span class="keyword">if</span>(magic != CodecConstants.MAGIC_HEAD) &#123;</span><br><span class="line">      in.resetReaderIndex();</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> TransportException(<span class="string">&quot;NettyDecoder: magic number error: &quot;</span> + magic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    in.skipBytes(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">int</span> contentLength = in.readInt();</span><br><span class="line">    <span class="keyword">if</span>(in.readableBytes() &lt; contentLength + <span class="number">8</span><span class="comment">/* requestId 8 byte */</span>) &#123;</span><br><span class="line">      in.resetReaderIndex();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全部读取</span></span><br><span class="line">    in.resetReaderIndex();</span><br><span class="line">    <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[CodecConstants.HEADER_SIZE + contentLength];</span><br><span class="line">    in.readBytes(data);</span><br><span class="line">    out.add(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先检查数据大小是否大于协议头，大于协议头我们才继续。</p><p>由于大于协议头，所以后面的16个字节的数据我们可以放心的读出，而不用担心越界异常。我们先检查了一下Magic头，看看是不是我们协议的数据，然后去读contentLength字段，我们就知道了这个数据头所携带的数据包有多大，然后看看ByteBuf中是否有足够的数据，如果没有直接返回，等待下次轮询，如果有了足够数据，则直接取出这个数据包中的所有数据，加入到out中。</p><p>千万要注意，这里只能读出本数据包中的数据，由于可能发生粘包，如果将ByteBuf中的数据全部读出来，可能会读到下个数据包的部分数据，导致真正要处理下个数据包的时候，读不出完整的数据，从而导致报错或者一些意想不到的错误，甚至死循环。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>我们进行了最最简单的编码，直奔最终的结果，去完成一次最简单的RPC调用，这些代码写完的时间非常短，所以里面可能有大量大量的隐藏问题。这段代码暂时仅用于学习和理解RPC框架流程，随着之后的完善，不排除用于生产环境的可能。</p><p>代码在这。</p><p>GitHub项目地址：<a href="https://github.com/zhengrenjie/susu">susu</a></p><p>之后会引入Zookeeper作为注册中心，支持Cluster和负载均衡部分，并完善代码逻辑，加入各种设置（本文中都没有设置入口，端口和ip全都写死的）。</p><p>如果要运行，请将Client中的sleep代码放出来，因为有可能调用的时候，Client和Server的TCP还没链接，之后也会修复这个问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这里我完成了最初始的Config层，Proxy层，Codec层，以及Transport层。&lt;/p&gt;
&lt;p&gt;具体来说，我使用Netty作为Transport层，并进行了半包和粘包的处理；我自己定义了自己的通信协议：susu协议，协议头待会会介绍；使用Java原生的动态代理作为</summary>
      
    
    
    
    <category term="Rpc" scheme="https://www.jelliclecat.cn/categories/Rpc/"/>
    
    
    <category term="Rpc" scheme="https://www.jelliclecat.cn/tags/Rpc/"/>
    
  </entry>
  
  <entry>
    <title>从零手撸一个Rpc框架-1-Dubbo和Motan</title>
    <link href="https://www.jelliclecat.cn/articles/Rpc/MyRpc-1/"/>
    <id>https://www.jelliclecat.cn/articles/Rpc/MyRpc-1/</id>
    <published>2019-09-06T14:47:50.000Z</published>
    <updated>2021-06-25T13:47:33.063Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Dubbo和Motan"><a href="#Dubbo和Motan" class="headerlink" title="Dubbo和Motan"></a>Dubbo和Motan</h3><p>这个Rpc博客系列的重点主要是记录我自己从零开发一款Rpc框架的过程，所以不会详细去介绍市面上已有的框架，但是在我们正式开始之前，还是不得不介绍一下市面上有代表性的Rpc框架，这里选了两款，dubbo和motan，dubbo是阿里研发的，已经捐献给了Apache；motan是微博的于2016年开源。</p><p>先说一下Rpc框架的分类，大致可以分为两类，这两类代表了两个不同的发展方向：</p><ul><li>服务治理型</li><li>跨语言型</li></ul><p>dubbo和motan框架都属于服务治理型框架，在具备基础的Rpc调用功能之上，提供了集群容错、路由、负载均衡、服务注册发现等具有集群治理属性的功能。而跨语言型Rpc框架，顾名思义是为了不同语言之间的服务能够互相调用彼此的服务，比较有名的有ICE，Thrift等，这些服务一般提供一种更加抽象的描述语言，这种语言用来抽象一个服务接口，然后根据不同的语言类型转化为不同的具体代码，这种框架不是我们要讨论的重点。</p><p>目前Java开发的Rpc框架更加侧重于服务治理型，这里再说一下Spring Cloud，Spring Cloud实际上属于微服务框架，Rpc只是Spring Cloud提供的其中一个功能，所以Spring Cloud是Rpc框架的更加先进的版本，但是Spring Cloud太庞大，其中集成的框架过于繁多，而dubbo和motan属于轻量型框架。</p><p>dubbo和motan本身非常的轻巧，dubbo和motan分别只含有13.6W行和3.5W行代码（包含测试代码），要知道SpringFramework有60W行代码。dubbo的代码稍多一下，因为dubbo对于不同的层提供了不同的实现，举个例子，dubbo在服务注册发现层，提供了consul、redis、default、multicast、nacos、sofa、zookeeper、etcd3这n种实现，在实际使用过程中，只会用得着其中一个，并且里面有些实现并没与太大的用处，可能仅供学习，比如没人能拿redis去做服务注册。相对来说motan的实现就轻巧很多，服务注册只支持了zookeeper和consul这两种最常用的框架。</p><h3 id="两个框架的区别"><a href="#两个框架的区别" class="headerlink" title="两个框架的区别"></a>两个框架的区别</h3><ul><li>dubbo在代理层使用了javassist框架作为代理生成器，javassist框架可以动态编译加载代码，这使得有些地方看起来十分容易让人疑惑，motan更加直接的使用了Java原生的动态代理，看起来更加亲切一些。</li><li>dubbo对于很多调用都抽象成了Invoke这个接口，然后这个接口上通常都会包一层Proxy，有的时候看起来给人感觉有点强行设计的感觉，没那么明了，motan的调用更加清晰一些。</li><li>dubbo提供了配置中心，而motan没有。</li><li>dubbo提供了大而全的各层的实现，motan只提供了最常用的实现。</li><li>一些细节的实现不同，比如dubbo过期使用了哈希轮转算法（代码是复制的netty的代码），motan使用了最朴素的实现方式。</li><li>dubbo提供了更丰富的请求重发策略。</li><li>dubbo提供了monitor模块。</li><li>motan使用了连接池，dubbo的dubbo协议使用单一链接。</li></ul><h3 id="两个框架的相同点："><a href="#两个框架的相同点：" class="headerlink" title="两个框架的相同点："></a>两个框架的相同点：</h3><p>看过源码就会发现，motan简直就是dubbo的精缩版，两个框架不仅在架构分层上惊人的相似，就连很多类的命名都一样，<strong>两者的设计几乎如出一辙</strong>。</p><p><strong>dubbo:</strong>  </p><ul><li><strong>config 配置层</strong>：对外配置接口，以 <code>ServiceConfig</code>, <code>ReferenceConfig</code> 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类</li><li><strong>proxy 服务代理层</strong>：服务接口透明代理，生成服务的客户端 Stub 和服务器端 Skeleton, 以 <code>ServiceProxy</code> 为中心，扩展接口为 <code>ProxyFactory</code></li><li><strong>registry 注册中心层</strong>：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 <code>RegistryFactory</code>, <code>Registry</code>, <code>RegistryService</code></li><li><strong>cluster 路由层</strong>：封装多个提供者的路由及负载均衡，并桥接注册中心，以 <code>Invoker</code> 为中心，扩展接口为 <code>Cluster</code>, <code>Directory</code>, <code>Router</code>, <code>LoadBalance</code></li><li><strong>monitor 监控层</strong>：RPC 调用次数和调用时间监控，以 <code>Statistics</code> 为中心，扩展接口为 <code>MonitorFactory</code>, <code>Monitor</code>, <code>MonitorService</code></li><li><strong>protocol 远程调用层</strong>：封装 RPC 调用，以 <code>Invocation</code>, <code>Result</code> 为中心，扩展接口为 <code>Protocol</code>, <code>Invoker</code>, <code>Exporter</code></li><li><strong>exchange 信息交换层</strong>：封装请求响应模式，同步转异步，以 <code>Request</code>, <code>Response</code> 为中心，扩展接口为 <code>Exchanger</code>, <code>ExchangeChannel</code>, <code>ExchangeClient</code>, <code>ExchangeServer</code></li><li><strong>transport 网络传输层</strong>：抽象 mina 和 netty 为统一接口，以 <code>Message</code> 为中心，扩展接口为 <code>Channel</code>, <code>Transporter</code>, <code>Client</code>, <code>Server</code>, <code>Codec</code></li><li><strong>serialize 数据序列化层</strong>：可复用的一些工具，扩展接口为 <code>Serialization</code>, <code>ObjectInput</code>, <code>ObjectOutput</code>, <code>ThreadPool</code></li></ul><p>[来源]：<a href="http://dubbo.apache.org/zh-cn/docs/dev/design.html">dubbo框架设计</a></p><p><strong>motan相对应的层:</strong>  </p><ul><li><strong>config</strong> 几乎一样</li><li><strong>proxy</strong> 几乎一样，使用的Java动态代理而不是javassist</li><li><strong>registry</strong> 几乎一样，支持了zookeeper和consul</li><li><strong>cluster</strong> 没有Directory和Router，提供了<code>Cluster</code>和<code>LoadBalance</code>接口</li><li><strong>没有moniter</strong>，但是提供了<code>Switcher</code>，可以实现简单的熔断功能</li><li><strong>protocol</strong> 使用了motan协议</li><li><strong>没有exchange</strong>，但提供了rpc层，用来封装底层的通信</li><li><strong>transport</strong> 几乎一样，提供了netty和netty4的实现</li><li><strong>serialize</strong> 几乎一样，提供了fastjson、Hessian2和Java原生实现</li></ul><p>在其他设计方面，两者都是用自定义的URL作为整个通信的总线，都是用SPI作为扩展接口，并都实现了ExtensionLoader，两者底层都使用netty作为传输层，当然dubbo支持其他的协议例如http等，两者都没有写什么代码注释，两者相似的地方还有很多很多，不一一列举了。</p><p>这里有关于motan更加详细的介绍：<a href="http://kriszhang.com/motan-rpc-impl/">从motan看RPC框架设计</a></p><p>关于两个框架更加详细的内容就不再继续介绍了，以后可能会专门写系列博客分析他们的代码，但是不是本系列的重点。</p><h3 id="比较的目的"><a href="#比较的目的" class="headerlink" title="比较的目的"></a>比较的目的</h3><p>我们比较了半天这两个框架，主要的目的是为了学习和弄明白一个Rpc框架需要哪些层次结构，或者说，一次Rpc调用需要经过哪些步骤，弄清楚了这些，一个Rpc的蓝图就已经在脑海里面了，之后要做的事情就是使用自己编程技巧将自己理解的Rpc框架写出来。</p><p>在开始敲代码之前，我们看看一次Rpc调用要经过哪些具体的步骤，一个Rpc框架需要分为Client端和Server端两边来看：Client端需要拿到接口的引用，Server端需要给Client暴露服务：</p><h4 id="1-Client端要拿到引用"><a href="#1-Client端要拿到引用" class="headerlink" title="1.Client端要拿到引用"></a>1.Client端要拿到引用</h4><p>例如我们有一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IService</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">say</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们的Client端的代码希望是这样的（具体的步骤我们写在代码注释里面了）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个引用</span></span><br><span class="line">    Reference&lt;IService&gt; reference = <span class="keyword">new</span> Reference&lt;&gt;();</span><br><span class="line">    <span class="comment">// 定义我们需要拿到的服务接口</span></span><br><span class="line">    reference.setInterfaceClass(IService.class);</span><br><span class="line">    <span class="comment">// 获取服务引用</span></span><br><span class="line">    IService service = reference.getRefer();</span><br><span class="line">    <span class="comment">// 调用服务的方法</span></span><br><span class="line">    String result = service.say(<span class="string">&quot;zrj&quot;</span>);</span><br><span class="line">    <span class="comment">// 获得返回</span></span><br><span class="line">    System.out.println(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Client端是没有<code>IService</code>的具体实现的，具体实现在Server端，所以可以想象的到，在调用<code>IService service = reference.getRefer();</code>时，我们返回的应该是<code>IService</code>的一个动态代理对象，这个对象里面封装了调用方法时具体执行的步骤，在调用<code>String result = service.say(&quot;zrj&quot;);</code>方法时，获取这次方法调用的各种参数、具体的方法信息等元数据，然后将这些元数据封装成一个请求，最后将这个请求序列化为byte数组，然后调用传输层去连接Server，并将请求发送给Server。最后Server返回一个封装后的结果，Client端收到这个结果后，获取结果并返回。</p><h4 id="2-Server端要暴露服务"><a href="#2-Server端要暴露服务" class="headerlink" title="2.Server端要暴露服务"></a>2.Server端要暴露服务</h4><p>在Client端调用之前，服务端必须先暴露自己的服务，我们希望服务端这样暴露服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一次暴露</span></span><br><span class="line">    Exporter&lt;IService&gt; exporter = <span class="keyword">new</span> Exporter&lt;&gt;();</span><br><span class="line">    <span class="comment">// 设置要暴露的服务接口，对应Client端</span></span><br><span class="line">    exporter.setInterfaceClazz(IService.class);</span><br><span class="line">    <span class="comment">// 设置服务接口的具体实现类</span></span><br><span class="line">    exporter.setRef(<span class="keyword">new</span> IServiceImpl());</span><br><span class="line">    <span class="comment">// 暴露服务</span></span><br><span class="line">    exporter.export();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// IService接口的实现</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IServiceImpl</span> <span class="keyword">implements</span> <span class="title">IService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;from rpc &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Server端需要根据Client端传过来的参数确定需要调用哪个服务的哪个方法，所以当我们调用<code>exporter.setInterfaceClazz(IService.class);</code>时，就使用反射的方法，找到这个接口中所有的方法签名，并缓存在Map中。当我们调用export的时候，实际上底层肯定是开启了一个端口去监听网络，如果收到了网络请求，那么就先反序列化，然后从请求中拿到需要调用的方法的类和名称，以及方法参数的值，然后去调用本地<code>IServiceImpl</code>中的具体方法，得到结果封装成一个类，然后序列化后通过传输层放回。</p><p>这就是Client端和Server端需要做的最基本的工作了。</p><p>可以看到，我们至少需要四个层次：Exporter&amp;Reference是最上层的Config层，Proxy代理层用来代理接口并封装底层的网络传输，Transport层用来封装网络传输，Serialization用来封装序列化和反序列化的相关操作。</p><h4 id="3-协议设计"><a href="#3-协议设计" class="headerlink" title="3.协议设计"></a>3.协议设计</h4><p>当我们在传输数据之前，需要写入额外的信息到数据包中，也就是所谓的协议头，这个协议头需要我们自己来定义。协议头中放入了一些基本的协议信息，例如MagicNumber、协议版本、传输数据类型、数据长度、请求Id等。之后会看到我自己设计的网络协议。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>最终我按照这条思路进行了简单的实现，下章会具体讲解。</p><p>通过看dubbo和motan两个框架的源码，我们弄懂了一个Rpc框架的内部原理，并对基本功能做了一个简单梳理。但是我们还差很多很多的功能以及面临很多的问题：</p><ul><li>请求重发怎么做</li><li>请求失败后的策略怎么抽象</li><li>Cluster怎么封装，负载均衡怎么做</li><li>在Transport层一个Client对一个Server是一个连接还是多个连接，是长连接还是短连接</li><li>各种设置如何从最上层传递到最下层，不同层的设置怎么区分</li><li>缓存怎么做</li><li>异步怎么做</li><li>服务注册发现怎么做</li><li>生命周期如何管理</li></ul><p>这些问题都会在之后的博客中一步一步解决。</p><p>GitHub项目地址：<a href="https://github.com/zhengrenjie/susu">susu</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Dubbo和Motan&quot;&gt;&lt;a href=&quot;#Dubbo和Motan&quot; class=&quot;headerlink&quot; title=&quot;Dubbo和Motan&quot;&gt;&lt;/a&gt;Dubbo和Motan&lt;/h3&gt;&lt;p&gt;这个Rpc博客系列的重点主要是记录我自己从零开发一款Rpc框架的过程</summary>
      
    
    
    
    <category term="Rpc" scheme="https://www.jelliclecat.cn/categories/Rpc/"/>
    
    
    <category term="Rpc" scheme="https://www.jelliclecat.cn/tags/Rpc/"/>
    
  </entry>
  
  <entry>
    <title>针对基本有序数列的改良冒泡排序</title>
    <link href="https://www.jelliclecat.cn/articles/Java/OooooSort/"/>
    <id>https://www.jelliclecat.cn/articles/Java/OooooSort/</id>
    <published>2019-09-02T11:51:50.000Z</published>
    <updated>2021-06-25T13:47:33.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="我把这个排序称为OooooSort"><a href="#我把这个排序称为OooooSort" class="headerlink" title="我把这个排序称为OooooSort"></a>我把这个排序称为OooooSort</h2><p>hahahaha虽然没有Java自带的TimSort高效，但也只是稍稍逊色，这是一个闲暇时做的小玩意~可以叫做双向冒泡法，或者改良冒泡法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双向冒泡，不需要额外存储空间，速度稍慢于tim sort</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zrj CreateDate: 2019/8/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OooooSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(ArrayList&lt;E&gt; list, Comparator&lt;E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(list == <span class="keyword">null</span> || list.size() == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxSorted = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> hasSwap;</span><br><span class="line">    E last;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      hasSwap = <span class="keyword">false</span>;</span><br><span class="line">      last = list.get(maxSorted);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; list.size() - j; i ++ )&#123;</span><br><span class="line">        E cur = list.get(i);</span><br><span class="line">        <span class="keyword">if</span>(comparator.compare(last, cur) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          hasSwap = <span class="keyword">true</span>;</span><br><span class="line">          list.set(i - <span class="number">1</span>, cur);</span><br><span class="line">          list.set(i, last);</span><br><span class="line">          E innerLast = list.get(i - <span class="number">1</span>);</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> k = i - <span class="number">2</span>; k &gt;=<span class="number">0</span>; k--) &#123;</span><br><span class="line">            E innerCur = list.get(k);</span><br><span class="line">            <span class="keyword">if</span>(comparator.compare(innerCur, innerLast) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              list.set(k + <span class="number">1</span>, innerCur);</span><br><span class="line">              list.set(k, innerLast);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">if</span>(!hasSwap) &#123;</span><br><span class="line">            maxSorted = i;</span><br><span class="line">          &#125;</span><br><span class="line">          last = cur;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      j++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (maxSorted &lt; list.size() &amp;&amp; hasSwap);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于基本有序的数列，快排的效率是非常低的，相对来说，冒泡的潜力要更高一些，但是冒泡做了很多无用的工作，所以我稍稍改进了一下，每次冒一次泡后，都回头对刚刚换下去的数据进行一下反向冒泡（沉底），这样，每次向上冒一次泡之后，身后的数据都已经是全局有序的了，还有一个优化点，冒泡的时候可以记录下最长未发生交换的位置，应为没有发生过交换，所以这批数据是已经有序的，上面的代码中maxSorted就是用来干这个的，这样下轮冒泡就减少了很多工作。</p><p>如果数据基本有序，效率可以逼近O（n），突破排序的算法理论极限了有木有，好了当然不是，算法理论极限是通用情况，这里是基本有序。</p><p>但是Java提供的TimSort性能更加优秀。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;我把这个排序称为OooooSort&quot;&gt;&lt;a href=&quot;#我把这个排序称为OooooSort&quot; class=&quot;headerlink&quot; title=&quot;我把这个排序称为OooooSort&quot;&gt;&lt;/a&gt;我把这个排序称为OooooSort&lt;/h2&gt;&lt;p&gt;hahahaha虽然</summary>
      
    
    
    
    <category term="Java" scheme="https://www.jelliclecat.cn/categories/Java/"/>
    
    
    <category term="Java" scheme="https://www.jelliclecat.cn/tags/Java/"/>
    
    <category term="排序" scheme="https://www.jelliclecat.cn/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java高性能编程串讲-IO读写的那些细节</title>
    <link href="https://www.jelliclecat.cn/articles/Java/Performance-3/"/>
    <id>https://www.jelliclecat.cn/articles/Java/Performance-3/</id>
    <published>2019-09-01T13:44:50.000Z</published>
    <updated>2021-06-25T13:47:33.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="〇、前言（碎碎念）"><a href="#〇、前言（碎碎念）" class="headerlink" title="〇、前言（碎碎念）"></a>〇、前言（碎碎念）</h2><p>磁盘的读写也同样是一个非常容易被忽略的点，在生产环境中也出现过由于磁盘读写代码编写不当造成的线上服务不可用，待会我会讲一下这个案例。磁盘是系统中最慢的IO之一，不当的编码对性能的影响非常大。</p><h2 id="磁盘篇"><a href="#磁盘篇" class="headerlink" title="磁盘篇"></a>磁盘篇</h2><h3 id="一、JVM堆内内存和堆外内存"><a href="#一、JVM堆内内存和堆外内存" class="headerlink" title="一、JVM堆内内存和堆外内存"></a>一、JVM堆内内存和堆外内存</h3><p>首先讲一下堆外内存，堆外内存是啥呢？比如我们new出来的对象，全部在JVM的堆内存中，我们写的绝大多数程序也都使用的是JVM的堆内存，当然堆内存在JVM中又被划分为很多块（Eden，S1，S2，Old等等），但这不是今天的重点，相信大家对堆内存还是非常熟悉的。那堆外内存是什么呢？就是非JVM管理的内存，是不是很神奇，Java是可以操作JVM内存以外的内存的，通过sun提供的UNSAFE类，可以通过<code>UNSAFE.allocateDirect</code>分配堆外内存（也可以用过ByteBuffer使用堆外内存），之所以叫UNSAFE类，是因为这部分内存需要我们自己管理，JVM不负责这块内存的管理（虽然FullGC对这块内存还是有效的），这块内存需要我们自己清理释放，使用起来没有JVM内存方便，但是堆外内存有非常多的优点是堆内存不具有的，其中非常重要的一点以及使用堆外内存的主要因素就是：堆外内存的IO速度优于堆内存的IO速度，但是缺点就是，分配堆外内存的速度是明显慢于堆内存的。</p><h3 id="二、IO读写"><a href="#二、IO读写" class="headerlink" title="二、IO读写"></a>二、IO读写</h3><h4 id="传统做法"><a href="#传统做法" class="headerlink" title="传统做法"></a>传统做法</h4><p>试想有这样一个应用：将本地磁盘中的一个文件通过网络发送给客户端。</p><p>习惯的想到使用InputStream和OutputStream，首先使用InputStream从本地磁盘读取文件，然后用一个buffer存在内存中，然后用OutputStream把buffer中的数据发送给客户端。</p><p>看起来是一个非常自然的过程，我们分析一下这个过程中的一些细节：数据从磁盘到我们的buffer都经历了些什么呢？</p><p>首先，我们调用InputStream的read方法的时候，read方法最终调用了JVM的native方法，而native方法中的read方法最终会调用系统调用read方法（linux自身的read方法），这个系统调用会导致系统从用户态切换到内核态，然后DMA（待会介绍DMA）把数据从磁盘搬到内核内存空间，然后CPU再将内核空间的数据拷贝到堆外用户内存，系统调用到这里结束，接下来的工作要交给JVM，所以需要从内核态切换为用户态，最后CPU还要将堆外内存拷贝进堆内存的buffer中，这时，我们才在buffer中拿到我们从磁盘读取的数据。</p><p>上面这个过程非常重要，仔细看一下，我们发现使用InputStream从磁盘中读取数据做了非常多的事情：</p><ul><li>一次磁盘读取</li><li>两次内存拷贝（内核空间到堆外用户空间，堆外到JVM堆内）</li><li>两次系统状态切换</li></ul><p>系统转态切换是非常耗时的，需要保存当前转态的上下文，并载入要转换转态的上下文，如果频繁的切换系统转态带来的开销也将非常可观。</p><p>到现在数据才读到我们的堆内存中，我们接下来还要将buffer中的数据通过OutputStream发送给客户端，这时我们同样进行了两次内存拷贝（堆内到堆外，堆外到内核空间），两次系统转态切换，以及一次网络IO。所以我们一共进行了4次内存拷贝，4次系统转态切换。</p><p>怎么样，是不是贼费事，我们看看有没有改进办法，我们将数据千辛万苦读到buffer中，然后又千辛万苦从buffer中扔给网络IO，其实完全没有必要从内核中读到堆内，这一步是多余的。</p><h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><p>为了优化这种情况，linux推出mmap系统调用代替read系统调用，该系统调用会将磁盘中的文件地址映射到内核空间中的地址，然后再将内核空间中的地址映射到用户空间中的一个地址，使得用户空间和内核空间共享一份数据，对于Java来说，JVM还会把堆外的用户空间映射到堆内存中，但是这是JVM的扩展行为，不属于mmap系统调用，所以JVM不是真正的共享，其中还是会发生拷贝。</p><p>Java中可以通过<code>FileChannel#map</code>方法调用mmap，通过使用mmap我们再看一下读取数据需要经过哪些过程：</p><ul><li>一次磁盘读取</li><li>一次内存拷贝（内核空间和堆外用户空间共享了，没有拷贝，JVM从堆外拷贝到堆内）</li><li>两次系统状态切换</li></ul><p>这样，我们读取数据就节约了一次内存到内存的拷贝，但是发送给网络IO无法使用mmap，仍然需要两次内存拷贝。所以使用mmap代替read之后，我们需要3次内存拷贝，4次系统转态切换。</p><h4 id="DMA（插个队）"><a href="#DMA（插个队）" class="headerlink" title="DMA（插个队）"></a>DMA（插个队）</h4><p>我们继续之前，可以先看一下DMA。DMA（Direct Memory Access，直接内存访问）是个什么东西呢？这个东西就很牛逼了，它是专门用来给内存“搬数据”的，可以称得上是内存专用的数据搬运工。为什么需要它呢，因为CPU忙啊，如果要从磁盘中搬个几百兆的数据到内存中，如果只依靠CPU去寻址，然后去搬数据，那要搬到什么时候啊，况且CPU是个大忙人啊，不能把宝贵的CPU资源用来搬数据，那岂不是太大材小用了，所以就设计了DMA这个东西，DMA是主板上的一个专门的芯片，它也可以对内存以及各种IO设备进行寻址、读数据、写数据，并且效率比CPU还要高，有了DMA的存在，CPU接到一个搬数据的任务的时候，只需要告诉DMA（快给忙人让路，费德罗！），从哪个设备的哪个地址，搬多少数据到哪个设备的哪个地址，一共三个参数，起始地址，数据长度，目标地址，然后DMA会获取一部分的总线控制权（<strong>注意是一部分哦，不是独占总线，不然CPU又没事情做了，DMA会和CPU时分复用总线，据一些大神实验，STM32某款CPU是 CPU:DMA 为3:2的比例分配总线占用时间的，不同的设备可能设置不一样吧，但是一定是同时使用的，不是某个设备独占</strong>），DMA完成数据搬运工作之后，会给CPU发送中断，通知CPU任务已经完成了。所以前面提到的从磁盘搬数据到内核空间，没错，就是DMA干的。现在的DMA已经更加厉害了，不仅仅能从磁盘搬数据到内存，也能直接作为其他外设IO和内存交换数据的桥梁。</p><p><a href="http://www.openedv.com/posts/list/48087.htm"><strong>求教DMA与CPU的同时工作问题</strong></a></p><h4 id="sendFile"><a href="#sendFile" class="headerlink" title="sendFile"></a>sendFile</h4><p>针对这么多的拷贝和系统转态切换，实在繁琐了，能不能进一步优化呢？DMA不正好是干这个的吗？核心思想就是现在不是要把磁盘的数据发送到网络IO吗，那我们直接使用DMA将磁盘的数据搬到内核空间，然后CPU将内核空间中的数据搬到网络IO的buffer中，再使用DMA把数据从buffer搬到网络IO，不就可以了吗？sendFile就这样诞生了，这样，我们只需要一次系统调用，就可以同时完成读写两个功能，这样，我们一共只需要一次内存拷贝，两次转态切换。sendFile的本质其实是直接沟通两个不同的外设IO，通过DMA将内存作为中继站。</p><p>Java中也可以使用sendFile，通过<code>FileChannel#transferTo</code>方法。这个方法需要传入另一个FileChannel，意味着将这两个FileChannel链接起来，数据可以在这两个FileChannel中透传。</p><h4 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h4><p>好了，可以说说零拷贝了，刚刚说了，CPU反复在不同的内存空间中来回搬运数据是低效的、不必要的，所以我们希望尽可能的在数据传输过程中，不要出现内存拷贝，这就是所谓的零拷贝，sendFile和mmap都实现了零拷贝，如果直接使用C语言确实就是这样，如果使用Java语言，mmap还是会有一次内存拷贝，堆外用户空间和堆内空间的互相拷贝，而sendFile即使在Java中也是没有内存拷贝的。</p><h3 id="三、Java中的优化"><a href="#三、Java中的优化" class="headerlink" title="三、Java中的优化"></a>三、Java中的优化</h3><p>Java已经对InputStream和OutputStream这些传统IO进行了优化，对于File的读写底层都已经改用了FileChannel，但是我们还是推荐自己使用FileChannel，那样会更加明白一些。</p><p>FileChannel还提供了write和read方法，这两个方法底层做了优化，有人测试，这两个方法已经能够满足绝大多数的使用需求了，只有对性能要求极其苛刻的情况下，或者在一些特殊场景下，才用去考虑是否使用map和transferTo方法。</p><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>其实还有一些问题，<strong>如果磁盘文件非常大</strong>，内存装不下，传统io、mmap、sendfile在Java中会分别怎么表现呢？</p><ul><li>如果使用传统IO读一个内存装不下的文件，会抛出OOM异常（因为你要先new一个buffer啊）。</li><li>mmap本质是对地址的映射，当文件过大时，mmap只会将文件的一部分数据映射到内存，当要访问的数据超出范围时，mmap会根据一些算法对内存中的数据和磁盘进行置换，有点类似换页算法。所以不会有OOM异常，但是如果访问文件跨度跳跃很大很频繁的话，mmap的性能会明显下降。</li><li>sendFile的话，由于它是直接沟通两个IO，如果内存不够，会分批搬运数据，所以也不会有OOM异常。</li></ul><p><strong>sendFile的缺点也非常明显</strong>，那就是数据只能透传，不能由程序介入访问数据，因为整个数据的搬运过程全部是在内核态下完成的，如果是透传数据，例如客户端需要下载一个服务器上的文件，那么可以使用sendFile，但是如果程序要对数据进行访问之后再给客户端，sendFile是做不到的。</p><p>大家有兴趣可以研究一下市面上流行的消息中间件框架，看看各种不同的框架是如何设计存储结构以及对应使用什么方法读写磁盘的，相信你会有很大的收获。</p><h3 id="五、用例分析"><a href="#五、用例分析" class="headerlink" title="五、用例分析"></a>五、用例分析</h3><p>之前出现一个事情，机器表现如下：</p><ul><li>一些普通的接口调用时长突然变长，一个很简单的接口要数秒甚至数十秒的时间才能返回。</li><li>CPU比平时稍高，但是不易察觉。</li><li>内存占用稳定，没有变化。</li><li>ps看了服务进程还在。</li><li>业务没有抛出任何异常</li></ul><p>到机器上打印一下日志，发现出现了大量的FullGC，由于机器上部署了不止一个服务，所以也没有马上确定内存是否超出JVM的堆内存，但是无疑是由于FullGC引起的服务假死。</p><p>看服务log，发现在出现这个现象的时间点上，有用户调用了一些批量下载任务，这个任务会批量返回一批PDF，这些PDF在另外的服务器上，本服务器会先去上游服务上下载这些PDF，然后再打包，最后返回给用户。</p><p>由于用户连续点击了几次大规模的下载任务，后端不断下载PDF后，堆内存逐渐消耗殆尽，并触发FullGC，但是FullGC之后又腾出一些空间，然后又下载了数个PDF，然后没过多久又触发了FullGC。</p><p>后来同事优化了，原因是同事一直使用的是InputStream将数据读到了堆内存中，用堆内存进行压缩操作，这次的任务量特别的多，超出了堆内存的限制，所以引起了程序的假死。</p><p>今天分析之后呢，相信你一定知道了，这个下载任务其实是从一个网络IO到另一个网络IO的数据透传，完全可以使用sendFile，这样，不用担心堆内存不足的问题，也不会引起任何GC，并且效率要高得多。</p><p>当然，中间有打包操作，可以借助Java对命令的操作，调用shell命令进行数据打包，中间存一下磁盘，整个过程还是只使用了sendFile以及内核内存空间。</p><p>这里JVM参数其实设计的也不合理（使用的是什么收集器我忘了，大概是CMS吧），JVM默认的是在98%的时间内没有释放2%的内存，才会报OOM异常，这里我们应该设置一个FullGC频率参数，超过一定频率就抛出OOM异常，让请求返回。</p><p>[参考]（里面有帮助理解的好看的图片，建议大家看看）：</p><p><a href="https://blog.csdn.net/u012129558/article/details/82878994">java NIO 缓存区之内核空间、用户空间和虚拟地址</a></p><p><a href="https://blog.csdn.net/caianye/article/details/7576198">sendfile:Linux中的”零拷贝”</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;〇、前言（碎碎念）&quot;&gt;&lt;a href=&quot;#〇、前言（碎碎念）&quot; class=&quot;headerlink&quot; title=&quot;〇、前言（碎碎念）&quot;&gt;&lt;/a&gt;〇、前言（碎碎念）&lt;/h2&gt;&lt;p&gt;磁盘的读写也同样是一个非常容易被忽略的点，在生产环境中也出现过由于磁盘读写代码编写不</summary>
      
    
    
    
    <category term="Java" scheme="https://www.jelliclecat.cn/categories/Java/"/>
    
    
    <category term="Java" scheme="https://www.jelliclecat.cn/tags/Java/"/>
    
    <category term="性能" scheme="https://www.jelliclecat.cn/tags/%E6%80%A7%E8%83%BD/"/>
    
    <category term="DMA" scheme="https://www.jelliclecat.cn/tags/DMA/"/>
    
  </entry>
  
  <entry>
    <title>Java高性能编程串讲-CPU缓存优化</title>
    <link href="https://www.jelliclecat.cn/articles/Java/Performance-2/"/>
    <id>https://www.jelliclecat.cn/articles/Java/Performance-2/</id>
    <published>2019-09-01T05:13:50.000Z</published>
    <updated>2021-06-25T13:47:33.060Z</updated>
    
    <content type="html"><![CDATA[<h2 id="〇、前言（碎碎念）"><a href="#〇、前言（碎碎念）" class="headerlink" title="〇、前言（碎碎念）"></a>〇、前言（碎碎念）</h2><p>上篇讲了内存利用率的问题，但其实Java的内存调优很多时候其实是JVM调优，这个内容也是一个老生常谈的问题了，需要一定的篇幅和案例，之后再讲吧~</p><h2 id="CPU篇"><a href="#CPU篇" class="headerlink" title="CPU篇"></a>CPU篇</h2><p>先看一段代码：</p><p><img src="https://raw.githubusercontent.com/zhengrenjie/PicGo/master/img/20190901120911.png"></p><p>这段代码来自Disruptor，Disruptor是一个基于内存的高性能异步处理框架。这段代码是啥子意思呢？</p><p>这还要从CPU缓存讲起。</p><p>假设CPU有三级缓存L1、L2、L3，并且CPU有2个核心，那么，两个核心中都有各自的L1、L2，也就是说不同核心使用的是不同的L1、L2缓存，既然使用了不同的缓存，那肯定就涉及到了数据一致性的问题，这里暂不探讨CPU的数据一致性协议（MESI协议），但一致性协议会带来性能问题，之后会简单介绍一下：伪共享问题。</p><p>不同Cache的速度不一样，L1&gt;L2&gt;L3&gt;内存，他们的速度比如下：</p><p><img src="https://raw.githubusercontent.com/zhengrenjie/PicGo/master/img/20190901121903.png"></p><p>当L1miss了之后，会访问L2，如果L2命中，会将L2要访问的数据，以及该数据之后的一部分数据一起加载到L1中来，因为根据程序的局部性原理，该数据周围的数据大概率会在接下来的程序中被访问。</p><p>那么一次究竟加载了多大的数据到内存中呢？</p><p><strong>64B</strong>，每次从更慢的缓存中都会以<strong>64B</strong>大小的数据块为单位加载到更快的缓存中。</p><h3 id="伪共享问题"><a href="#伪共享问题" class="headerlink" title="伪共享问题"></a>伪共享问题</h3><p>所谓的伪共享问题，是由于CPU的一致性协议引起的。由于每个CPU核心拥有自己的L1、L2缓存，但是由于数据是以64B为单位从低级缓存中加载过来的，所以，这64B的数据可能同时包含两个不同核心需要访问的数据，那么，当一个CPU核心修改了其中的某些数据，而另一个CPU核心是从自己的缓存中读取数据，那就会出现数据不一致问题。为了让数据保持一致，如果一个CPU核心修改了被共享到不同缓存中的数据，那么所有拥有这块64B数据的缓存就会被通知无效，在下次访问这块数据时，CPU发现这是一块无效数据，就会直接从内存中读取。</p><p>由上面的表可以看出，内存的访问速度比L1慢两个数量级，比L3也要慢一个数量级，如果在高并发场景下频繁发生伪共享问题，导致CPU频繁直接从内存中拿取数据的话，就会导致系统性能下降。</p><p>有什么好的解决办法没有呢？有，请看文章开头的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LhsPadding</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6, p7;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Value</span> <span class="keyword">extends</span> <span class="title">LhsPadding</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RhsPadding</span> <span class="keyword">extends</span> <span class="title">Value</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> p9, p10, p11, p12, p13, p14, p15;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码保存了一个long数据并为了避免伪共享做了一件暴力的事情，那就是加入Padding数据，前后各加入了7个long，加上自己前后刚好就是64B的大小，这样就能保证这个long值不与其他的值共享缓存，这样就避免了伪共享问题。但是，避免伪共享并不代表着cache可以100%命中这个数值而不用去访问内存，因为在这个字段自己被并发访问时，仍需要与内存进行数据同步，保证该字段的可见性（该代码中就加入了volatile字段保证了可见性）。</p><p><strong>不要混淆伪共享和可见性</strong>，伪共享是不同核心访问同一个Cache块中的其他数据引起的缓存失效，而可见性是为了保证不同线程对于同一数据的范围具有数据一致性。说白了，伪共享问题是和自己同一数据块的其他数据被修改引起的，自己是被牵连的，而可见性问题是自己本身被修改了，需要告诉其他可以访问自己的线程，本质上是两个完全不同的问题，只不过现象都是缓存失效。这段代码只是针对解决伪共享问题，对于可见性还是只能老老实实的加上了volatile字段。</p><h2 id="番外1，演示一下CPU缓存命中与不命中的性能差异"><a href="#番外1，演示一下CPU缓存命中与不命中的性能差异" class="headerlink" title="番外1，演示一下CPU缓存命中与不命中的性能差异"></a>番外1，演示一下CPU缓存命中与不命中的性能差异</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> length = <span class="number">32</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span>[][] longs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">  longs = <span class="keyword">new</span> <span class="keyword">long</span>[length][];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    longs[i] = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">      longs[i][j] = <span class="number">1l</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  hitCache();</span><br><span class="line">  catchMiss();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示缓存命中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hitCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; length; x++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="number">6</span>; y++) &#123;</span><br><span class="line">      sum += longs[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.print(<span class="string">&quot;hitCache: &quot;</span>);</span><br><span class="line">  System.out.println(System.currentTimeMillis() - start);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存位未命中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">catchMiss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="number">6</span>; y++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; length; x++) &#123;</span><br><span class="line">      sum += longs[x][y];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.print(<span class="string">&quot;catchMiss: &quot;</span>);</span><br><span class="line">  System.out.println(System.currentTimeMillis() - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://raw.githubusercontent.com/zhengrenjie/PicGo/master/img/20190901124338.png"></p><p>上图中用了6个long去填充一个缓存块（为啥是6个呢？因为还有对象头呀，不过这里代码写错了一点，数组对象头有24B，所以应该只有5个long就可以去填充一个缓存块了，但是没有太大关系，还是可以看出明显的效果）。</p><p>是不是很神奇，同一个数组不同的访问顺序，性能上有4倍的差别。</p><h2 id="番外2，MESI协议"><a href="#番外2，MESI协议" class="headerlink" title="番外2，MESI协议"></a>番外2，MESI协议</h2><p>每个64B的缓存块都有一个2bit标志位，用于标识四种状态：</p><ul><li>modify：当前CPU cache拥有最新数据（最新的cache line），其他CPU拥有失效数据（cache line的状态是invalid），虽然当前CPU中的数据和主存是不一致的，但是以当前CPU的数据为准；</li><li>exclusive：只有当前CPU中有数据，其他CPU中没有改数据，当前CPU的数据和主存中的数据是一致的；</li><li>shared：当前CPU和其他CPU中都有共同数据，并且和主存中的数据一致；</li><li>invalid：当前CPU中的数据失效，数据应该从主存中获取，其他CPU中可能有数据也可能无数据，当前CPU中的数据和主存被认为是不一致的；</li></ul><p>对于invalid而言，在MESI协议中采取的是写失效（write invalidate）。</p><p>后面具体的情况就不一一分析了，我自己也没有仔细看完（逃</p><p><a href="https://www.cnblogs.com/snow826520/p/8574824.html">CPU中的cache结构以及cache一致性</a></p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>今天简单的讲了一下CPU的缓存，告诉大家：Java也是可以做CPU优化的！虽然这种优化只在非常极端的情况下会被用到，但是在今天架构满天飞，中间件崛起的大环境下，Java跟高性能这个话题的关系越来越密切，市面上出现了很多Java的高性能框架，例如netty，netty中也用到了今天讲的优化方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InternalThreadLocalMap</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Cache line padding (must be public)</span></span><br><span class="line"><span class="comment">// With CompressedOops enabled, an instance of this class should occupy at least 128 bytes.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">long</span> rp1, rp2, rp3, rp4, rp5, rp6, rp7, rp8, rp9;</span><br></pre></td></tr></table></figure><p>这是netty中的一段代码，是不是会心一笑。</p><p>如今大量的开源框架都使用netty作为传输层框架，例如hadoop，dubbo等等，netty的性能和可用性都到达了一个巅峰，netty的作者也曾说过：“netty的每一个细节都经过了精心的设计”。</p><p>我想说的是，也许作为一名Web工程师，这些优化方法离你非常的远，可能几乎不会用到，你的目光可能更多的集中在SQL的优化或者业务代码上，但是，如果想更近一步做一个架构师，或者中间件专家等等，都需要掌握计算机系统底层原理甚至是硬件原理，以及掌握自己使用的语言是如何与系统相互作用的，并逐渐精通。我自己也在往这方面努力，希望能和大家共同进步。</p><p>下一节会介绍一下Java对于磁盘的操作~</p><p><strong>哦对了</strong>，你知道为什么说二分法的性能不好了吗？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;〇、前言（碎碎念）&quot;&gt;&lt;a href=&quot;#〇、前言（碎碎念）&quot; class=&quot;headerlink&quot; title=&quot;〇、前言（碎碎念）&quot;&gt;&lt;/a&gt;〇、前言（碎碎念）&lt;/h2&gt;&lt;p&gt;上篇讲了内存利用率的问题，但其实Java的内存调优很多时候其实是JVM调优，这个内容</summary>
      
    
    
    
    <category term="Java" scheme="https://www.jelliclecat.cn/categories/Java/"/>
    
    
    <category term="Java" scheme="https://www.jelliclecat.cn/tags/Java/"/>
    
    <category term="性能" scheme="https://www.jelliclecat.cn/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>Java高性能编程串讲-容易忽略的对象头</title>
    <link href="https://www.jelliclecat.cn/articles/Java/Performance-1/"/>
    <id>https://www.jelliclecat.cn/articles/Java/Performance-1/</id>
    <published>2019-08-31T13:45:50.000Z</published>
    <updated>2021-06-25T13:47:33.044Z</updated>
    
    <content type="html"><![CDATA[<h2 id="〇、前言（碎碎念）"><a href="#〇、前言（碎碎念）" class="headerlink" title="〇、前言（碎碎念）"></a>〇、前言（碎碎念）</h2><p>哇好久没写博客了，不是我忘了，只是这段时间实在太忙了，再一个也想多积累积累，这样写出来的东西更厚实一点，这段时间看了netty和dubbo的一些源码（当然spring的一些其他的代码也有看），有空给大家分享一下。</p><p>这次主要讲下java的性能优化，涉及多线程，内存，磁盘，CPU等，不成体系，都是一些用到的小点，在这里做个记录。</p><h2 id="内存篇"><a href="#内存篇" class="headerlink" title="内存篇"></a>内存篇</h2><p>最近有一个需求，在业务中需要频繁的判断某些用户是否属于活跃用户，并找出非活跃用户，用户用id唯一标识，id是一个long，并且这批用户需要实时更新，因为离当前时间点越近操作过的用户越活跃。</p><p>这个问题可以转换为，n个long在内存中实现快速查找，并实现快速更新。</p><p>很快就能想到，用一个Set&lt; Long&gt;对所有活跃用户的id进行缓存，Set的查找速度非常之快，并且接口十分方便我们进行查找和添加操作，看起来是一个最优的选择。</p><p>真的如此简单吗？这一个学Java半天的程序员也能解决吧？</p><p>当然没这么简单，对于Set来说，如果这批用户量比较小，只有几W，那也没有什么问题，但是活跃用户量可能达到100W级别（数字脱敏），并根据不同的时间尺度数量级会发生很大的变化，时间尺度越大，人数可能更多。那放在Set里面有什么问题呢？</p><p>到linux服务器上，java -version，一般来说现在都是使用64位的JDK，64位的JDK有16B的对象头（数组对象有24B的对象头，多一个字节保存数组长度），HashSet本质上是一个value是一个固定的Object引用的HashMap，HashMap使用的是一个Entry&lt;K, V&gt;[]存储数据，那么100W个数据，就有100W个Entry对象，一个Entry对象占用多少内存呢？看一下源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">      <span class="keyword">final</span> K key;</span><br><span class="line">      V value;</span><br><span class="line">      Node&lt;K,V&gt; next;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>int hash</code>4B</li><li><code>K key</code>是一个对于Long的引用，64位下占用8B，同时上面的hash内存对齐，hash实际占用8字节</li><li><code>V value</code>是一个对于Object的引用（见Set源码），占用8字节</li><li><code>next</code>是一个对Node的引用，占用8B</li><li>long被包装成了Long，占用16B的对象头+8字节的long value</li></ul><p>你以为这就完了吗？naive，JDK8之后，hashmap会自动转换成红黑树，所有的Node数据结构也被转为TreeNode，TreeNode继承自LinkedHashMap.Entry，我们来看看这两个东西：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LinkedHashMap.Entry</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; before, after;</span><br><span class="line">        Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="keyword">boolean</span> red;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>继续来看内存占用情况：</p><ul><li>before, after两个引用占16B</li><li>parent, left, right, prev 四个引用占32B</li><li>red虽然内存边界是对的，但是整体数据结构需要内存对齐，故也占用8B</li></ul><p>好来统计一下，Set里面装一个long需要多少字节呢？答案是128B，内存利用率是 8/128 = 6.25%。鼻血是不是都要出来了，那100W个数据需要多少内存呢？就是128MB，这显然是不能接受的。（你硬要说能接受也行8，内存大也没毛病）</p><p>好了，那用Set行不通了，怎么办呢，这么多对象头，这么多引用，太浪费了，直接用一个long[]不就搞定了吗？long[]只有一个对象，所以只有一个对象头，要查找的话，100W个数据在内存中二分查找的效率也是非常棒的（稍逊色于HashSet）。其实这已经可以当做是一个可选方案了（后面我们会讨论二分的效率问题），我们只需要8M的内存就解决了问题，并且效率也非常不错，但是添加数据会比较麻烦。</p><p>有没有更好的方法呢？仔细审题，我们重点是要找出非活跃用户，但其实这里没那么严格，100W个用户少找出10来非活跃用户个不会有任何区别，基于这个特点，我的脑海中浮现出了一个神奇的算法，叫做布隆过滤器。</p><p><a href="https://www.jianshu.com/p/bed57bfad826">布隆过滤器</a></p><p>布隆过滤器的原理大致讲一下，布隆过滤器用一个bit数组存储数据，对于一个加入布隆过滤器的元素，会进过k个哈希函数，然后布隆过滤器把k个散列的结果位都置为1，当要判断一个元素是否在布隆过滤器中时，先对这个元素进行k次散列，然后检查所有的散列结果在bit数组中的值是否全为1，如果都为1，则这个元素可能在布隆过滤器中，如果不都为1，则这个元素一定不在布隆过滤器中。</p><p>好了怎么用呢？目前实现比较好的布隆过滤器算法是guava，建议使用27版本以上，因为布隆过滤器一直被标位开发中，但是27版本以上的实现已经相当完备了，例如ThreadSafe和持久化都做了支持。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> BloomFilter&lt;Long&gt; BLOOM = BloomFilter.create(</span><br><span class="line">      Funnels.longFunnel(), <span class="number">1000000</span>, <span class="number">0.001</span>);</span><br></pre></td></tr></table></figure><p>这段代码的意思是说，预计有100W个元素会进入布隆过滤器，误判率为0.1%，这样，布隆过滤器会根据自身的算法计算出hash函数的最佳个数以及存储需要的bit数组，这里不做推导，虽然我会，嘻嘻~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1) Optimal k = b * ln2</span></span><br><span class="line"><span class="comment">// 2) p = (1 - e ^ (-kn/m))^k</span></span><br><span class="line"><span class="comment">// 3) For optimal k: p = 2 ^ (-k) ~= 0.6185^b</span></span><br><span class="line"><span class="comment">// 4) For optimal k: m = -nlnp / ((ln2) ^ 2)</span></span><br></pre></td></tr></table></figure><ul><li>k代表hash函数的个数</li><li>b代表m/n</li><li>m bit数组的大小</li><li>n 我们传入的100W</li><li>p 误判率</li></ul><p>所以可以直接算出m的大小为不到146W，也就是说，内存占用量只用了1.8MB。并且其写入性能要稍优于HashSet，查询性能也非常快，只计算k个hash函数以及读几个bit位，guava使用的是murmur哈希算法，这个算法目前是性能以及散列效果最好的一个算法，这里不多介绍。</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>对于Java内存的使用，对象头是一个很容易忽略的细节，对于这种大量小数据结构的数据来说，使用HashSet是非常奢侈的，还有一个点，二维数组也是有n多个对象头的，long[1000][10]这种数组有1000个对象头，并且数组的对象头比非数组要多出8个字节（32位是4个），但是long[10][1000]只有10个对象头。所以这种多维数组还是要悠着点，不然可能连对象头都装不下。</p><p>二分法的搜索的性能问题下章会讲。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;〇、前言（碎碎念）&quot;&gt;&lt;a href=&quot;#〇、前言（碎碎念）&quot; class=&quot;headerlink&quot; title=&quot;〇、前言（碎碎念）&quot;&gt;&lt;/a&gt;〇、前言（碎碎念）&lt;/h2&gt;&lt;p&gt;哇好久没写博客了，不是我忘了，只是这段时间实在太忙了，再一个也想多积累积累，这样写出</summary>
      
    
    
    
    <category term="Java" scheme="https://www.jelliclecat.cn/categories/Java/"/>
    
    
    <category term="Java" scheme="https://www.jelliclecat.cn/tags/Java/"/>
    
    <category term="性能" scheme="https://www.jelliclecat.cn/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程：深入理解volatile关键字以及线程可见性</title>
    <link href="https://www.jelliclecat.cn/articles/MutiThread/volatile/"/>
    <id>https://www.jelliclecat.cn/articles/MutiThread/volatile/</id>
    <published>2019-06-14T10:35:50.000Z</published>
    <updated>2021-06-25T13:47:33.051Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、volatile关键字"><a href="#一、volatile关键字" class="headerlink" title="一、volatile关键字"></a>一、volatile关键字</h2><p>我们先看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisableTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> weight = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> VisableTest().test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread A = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            weight = <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread B = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (weight != <span class="number">200</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;visable&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        A.start();</span><br><span class="line">        B.start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出什么呢？答案是什么也不输出。</p><p>这涉及到内存可见性的问题。每个线程启动的时候回分配一个”工作空间”，”工作空间”包含一些数据的副本，包括类中的变量等，线程在修改这些数据的时候，修改的是自己”工作空间”中的数据，这些数据什么时候被写回主存取决于JVM，例如上面的例子，在我的本地测试环境，线程A修改的weight = 1，永远不会被写入主存中，所以线程B什么也不会打印。</p><p>volatile关键字就是干这个活的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> weight = <span class="number">200</span>;</span><br></pre></td></tr></table></figure><p>在weight前面加上volatile关键字后线程A修改weight的时候，会强制写回主存中，B读取weight的时候也会强制从主存中读取，这样就保证了A修改的weight和B读取的weight是用一份值。</p><h2 id="二、-volatile隐患"><a href="#二、-volatile隐患" class="headerlink" title="二、 volatile隐患"></a>二、 volatile隐患</h2><p><strong>很多专家不建议使用volatile关键字。</strong></p><p>初期synchronized性能较差，对于上面代码中的这种情形下，使用synchronized加锁保证可见性会带来很大的性能问题，而且非常大材小用，并且上述代码中没有原子性问题（原子性问题在synchronized和volatile两个关键字中很容易造成疑惑，后面会解释），于是针对这种情况的优化目的，加入了volatile关键字，使得被volatile关键字修饰的变量可以保证可见性。</p><p>在现在的JDK版本下（1.6版本synchronized关键字被大幅优化后，以及JUC包的推出），不再推荐使用volatile关键字，因为volatile关键字确实在某种程度上给人造成疑惑。</p><p>我认为造成疑惑的罪魁祸首是volatile只提供可见性但是不提供原子性，例如weight++操作会在并发场景下失败，即使weight使用volatile修饰，这是一个经典的例子，weight++实际上是三个操作：取出weight、weight递增、写回weight。这三个操作如果不能够保证原子性，某些线程的操作可能会被覆盖掉，因为某些线程可能读出了正处于修改过程中的weight（发生了脏读，参考<a href="https://www.jelliclecat.cn/articles/%E5%88%86%E5%B8%83%E5%BC%8F/2pc.html">事务隔离级别、CAP理论、BASE理论</a>）。锁具有两个主要特性：原子性和可见性，而volatile看起来像半个锁，但是因为volatile足够轻量，性能足够好，这就诱导大家面对并发问题时优先考虑volatile，而同时可见性和原子性是两个复杂的概念，在一个复杂的系统中，即使是一个老手也需要一些时间去分辨某些变量是否需要可见性和原子性，这就极其容易造成volatile关键字的误用和滥用。</p><p><strong>推荐的做法（在成为一个真正的高手之前）：</strong></p><ul><li>对变量的写操作不依赖于当前值。</li><li>该变量没有包含在具有其他变量的不变式中。</li></ul><p>也就是说，对于存在竞争的变量，仅当变量的状态与系统中任何变量（包括自己）无关时，可以使用volatile，并只做最简单的赋值和读取。简单说，只在系统标志位中使用volatile变量。</p><p>在判断原子性是否需要时，要仔细核对：即使weight=1如此简单的赋值操作也允许被打断去执行其他线程的内容，而不会对系统造成任何影响，那就说明不需要原子性。</p><p>如果可见性和原子性都不能确定，但是你还心存担心的话，那么直接使用锁或者原子类去同步吧，这样可以睡个好觉：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisableTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger weight = <span class="keyword">new</span> AtomicInteger(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> VisableTest().test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread A = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            weight.set(<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread B = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (weight.get() != <span class="number">200</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;visable&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        A.start();</span><br><span class="line">        B.start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三-、-结论"><a href="#三-、-结论" class="headerlink" title="三 、 结论"></a>三 、 结论</h2><p>在使用volatile变量去达到自己想要达到的目的时，必须100%确认你已经明白它会怎样运作，否则还是使用同步锁或JUC包下的原子类代替。</p><p>另外，通过上面的分析，其实volatile的适用场景非常的有限，如果在一个系统中发现大量的变量都加上了volatile关键字，那么你要小心了，因为要么volatile被滥用了，要么作者的某些目的无法通过众多的volatile去达到。</p><p>如有错误，欢迎指正~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、volatile关键字&quot;&gt;&lt;a href=&quot;#一、volatile关键字&quot; class=&quot;headerlink&quot; title=&quot;一、volatile关键字&quot;&gt;&lt;/a&gt;一、volatile关键字&lt;/h2&gt;&lt;p&gt;我们先看一个例子：&lt;/p&gt;
&lt;figure clas</summary>
      
    
    
    
    <category term="MutiThread" scheme="https://www.jelliclecat.cn/categories/MutiThread/"/>
    
    
    <category term="Java" scheme="https://www.jelliclecat.cn/tags/Java/"/>
    
    <category term="多线程" scheme="https://www.jelliclecat.cn/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>事务隔离级别、CAP理论、BASE理论</title>
    <link href="https://www.jelliclecat.cn/articles/DCS/CAP-BASE/"/>
    <id>https://www.jelliclecat.cn/articles/DCS/CAP-BASE/</id>
    <published>2019-06-11T10:35:50.000Z</published>
    <updated>2021-06-25T13:47:33.046Z</updated>
    
    <content type="html"><![CDATA[<h2 id="〇、-ACID"><a href="#〇、-ACID" class="headerlink" title="〇、 ACID"></a>〇、 ACID</h2><p>ACID是计算机领域一个耳熟能详的术语，讲的是事务的四大特性：原子性（Atomicity），一致性（Consistency），隔离性（Isolation），持久性（Durability）。</p><h3 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1. 原子性"></a>1. 原子性</h3><p>指一个事务要么全部成功，要么全部失败，不允许出现中间状态。</p><h3 id="2-一致性"><a href="#2-一致性" class="headerlink" title="2. 一致性"></a>2. 一致性</h3><p>指多个事务并发的情景下，系统必须如同串行执行所有的事务一样，不管并发的过程中具体如何调度，最终的结果都应该符合逻辑预期的结果，这个逻辑预期的结果等于串行执行所有事务的结果。</p><h3 id="3-隔离性"><a href="#3-隔离性" class="headerlink" title="3. 隔离性"></a>3. 隔离性</h3><p>多个事务并发的环境中，每个事务在执行的生命周期里面，都好像是在独占系统运行，不用的事务之间不会感知到彼此的存在，这种感知指的是数据的变化，即对于每个事务操作的数据，都不会受其他事务操作的影响。</p><h3 id="4-持久性"><a href="#4-持久性" class="headerlink" title="4. 持久性"></a>4. 持久性</h3><p>指事务执行完后，该事务对数据的更改便持久存储在数据库中，不会被回滚。</p><h2 id="二、-事务隔离级别"><a href="#二、-事务隔离级别" class="headerlink" title="二、 事务隔离级别"></a>二、 事务隔离级别</h2><p>标准SQL规范中，定义了4个事务隔离级别：Read Uncommitted、Read Committed、Repeatable Read、Serializable，隔离级别严格性从低到高。</p><p>说道隔离界别，那就先说说脏读、不可重复读、幻读。</p><h3 id="1-脏读"><a href="#1-脏读" class="headerlink" title="1. 脏读"></a>1. 脏读</h3><p>有两个事务：A和B。有数据n=500。</p><ul><li>事务B开启事务并Write——n=300</li><li>事务A开启事务并Read——n=300</li><li>事务B Commit or Rollback</li></ul><p>这时候A读到的n=300就是脏读，应为事务B还没有提交，A读到了B还没有提交的数据，这个数据可能被B回滚了，所以可能是一个无效数据，也可能是一个中间数据。</p><h3 id="2-不可重复读"><a href="#2-不可重复读" class="headerlink" title="2. 不可重复读"></a>2. 不可重复读</h3><p>有两个事务：A和B。有数据n=500。</p><ul><li>事务A开启事务并Read——n=500</li><li>事务B开启事务并Write——n=300</li><li>事务B Commit</li><li>事务ARead——n=300</li></ul><p>A在自己的事务周期中连续读了两次n，第一次读取的是500，第二次读取的是300。</p><p>注意，不可重复读和脏读的区别在于事务B是否提交，如果B在A第二次读取的时候已经提交了修改，那就是不可重复读，脏读更侧重与读到其他事务还没有提交的数据。</p><h3 id="3-幻读"><a href="#3-幻读" class="headerlink" title="3. 幻读"></a>3. 幻读</h3><p>有两个事务：A和B。有数据n0=100，n1=200。</p><ul><li>事务A开启并ReadAll——n0=100，n1=200</li><li>事务B开启并Write—–n0=100，n1=200，n2=300</li><li>事务B Commit</li><li>事务A ReadAll——n0=100，n1=200，n2=300</li></ul><p>A两次查询得到了新插入的数据，而旧的数据没有被改变。</p><p><strong>不同的隔离级别解决了不同的问题：</strong></p><table><thead><tr><th align="center">隔离级别</th><th align="center"><strong>脏读</strong></th><th align="center"><strong>不可重复读</strong></th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">Read Uncommitted</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">Read Committed</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">Repeatable Read</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">Serializable</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><h2 id="二、-CAP理论"><a href="#二、-CAP理论" class="headerlink" title="二、 CAP理论"></a>二、 CAP理论</h2><p>CAP同样指的是三个字母：一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance），CAP理论指的是，一个系统中，不可能同时满足这三个条件。注意这里不需要强调是分布式系统，因为分区容错性就隐喻着系统是分布式系统。</p><p><strong>分区容错性</strong>是分布式系统的基本特性，指当一个节点挂掉的时候，总是有备用的节点顶替故障节点，继续对外提供服务。分区容错性是分布式系统中不可以放弃的条件，放弃了分区容错性就意味着无法保证系统不间断的提供对外的服务。</p><p><strong>可用性</strong>是指系统需要在限定时间内返回结果，例如在淘宝上添加一个商品到购物车，网站的期待响应时间是300ms，再例如使用HIVE查询海量数据，一条SQL的查询时间应该在分钟级别。这些服务的响应时间都不应该超过用户的心理预期或者逻辑预期，并且需要返回逻辑正确的结果，这就称之为服务可用。</p><p><strong>一致性</strong>是指对于不同的子节点，任意一个节点对于数据的修改对其他所有节点都是立刻可见的，也就是说，比如在A节点修改了一条数据，那么B节点应该能马上读到这条修改过的数据。</p><p>为什么说这三条不能全部同时满足呢？没有严谨的逻辑证明，我只说说我自己的理解。</p><p>首先分区容错性是必须存在的，这是分布式系统的基本特性，必须满足。反过来说（反证法），假设不用保证分区容错性，则系统就是单点系统，虽然不存在一致性的问题，但是单点系统有严重的可用性问题，所以可用性依赖于分区容错性的，换句话说，没有分区容错性就不能保证可用性，所以分区容错性无论如何必须满足。对于一致性和可用性，我们期待对一致性的保证不会对可用性造成影响，但这是不可能的。为了严格保证一致性，节点必须暂停服务，去完成和其他节点的数据同步，这个数据同步工作是同步完成的，同步意味着阻塞（并且阻塞时间是不可预期的），阻塞意味着服务不可用，如果异步同步数据，则无法严格保证数据的一致性，因为异步同步的过程依赖于系统调度，同步数据之前完全可能有数据查询请求打过来。</p><h2 id="三、BASE理论"><a href="#三、BASE理论" class="headerlink" title="三、BASE理论"></a>三、BASE理论</h2><p>如上文说，CAP不可能在一个系统中同时得到保证，但是CAP的每一个条件都是不可以完全放弃的，所以工程师只能在CAP的三个条件中寻找平衡。</p><p>分区容错性是没有退路的，所以往往在可用性和一致性之间寻找平衡。这就有了BASE理论。BASE理论指的是：</p><ul><li>Basically Available （基本可用）</li><li>Soft State （软状态）</li><li>Eventually Consistent （最终一致性）</li></ul><p><strong>基本可用</strong>讲的是分布式系统允许损失部分可用性：</p><ul><li><strong>响应时间：</strong>正常情况下一个请求的响应时间为200ms，但是少数情况下（节点故障恢复、切换故障节点等情况），响应时间达到了1s，这是还是认为系统可用。</li><li><strong>功能损失：</strong>例如在电商网站促销高峰，为了保护系统，将部分用户引导到一个降级页面分流，着也可以看做系统基本可用，虽然没有完全满足用户的预期，但是也及时给予用户一个合理的答复。</li></ul><p><strong>软状态</strong>是指系统允许存在中间状态，但是不影响最终的结果。例如，两个窗口在出售同一张火车票，现在还剩1张，两个窗口看到的余票都是1张，这是有一个窗口已经卖出了这一张火车票，另一个窗口还没来得及更新数据，这时候旅客看到了余票就去购买，但是最终会购买失败。这就是所谓的可以存在中间状态，但是不影响最终结果。</p><p><strong>最终一致</strong>指的是数据的状态可以在某些时候不一致，但是最终数据都会达到一直。</p><p>这篇算是一个铺垫，之后会介绍2PC算法，3PC算法，Paxos算法等。</p><p>如果有什么问题，欢迎指出~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;〇、-ACID&quot;&gt;&lt;a href=&quot;#〇、-ACID&quot; class=&quot;headerlink&quot; title=&quot;〇、 ACID&quot;&gt;&lt;/a&gt;〇、 ACID&lt;/h2&gt;&lt;p&gt;ACID是计算机领域一个耳熟能详的术语，讲的是事务的四大特性：原子性（Atomicity），一致性（</summary>
      
    
    
    
    <category term="DCS" scheme="https://www.jelliclecat.cn/categories/DCS/"/>
    
    
    <category term="Zookeeper" scheme="https://www.jelliclecat.cn/tags/Zookeeper/"/>
    
    <category term="分布式" scheme="https://www.jelliclecat.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>spring-beans包源码阅读-4-BeanFactory</title>
    <link href="https://www.jelliclecat.cn/articles/Spring/spring-beans-4/"/>
    <id>https://www.jelliclecat.cn/articles/Spring/spring-beans-4/</id>
    <published>2019-06-01T10:16:50.000Z</published>
    <updated>2021-06-25T13:47:33.055Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><p><a href="https://www.jelliclecat.cn/articles/Spring/Spring-beans-1.html">Spring阅读前言</a>-里面讲了一些心路历程</p><p><a href="https://www.jelliclecat.cn/articles/Spring/spring-beans-2.html">spring-beans包源码阅读-2-BeanWrapper</a></p><p><a href="https://www.jelliclecat.cn/articles/Spring/spring-beans-3.html">spring-beans包源码阅读-3-BeanDefinition</a></p><p>终于到重点啦！由于BeanFactory太复杂了，这次我们会用单元测试调试跟踪源码。</p><h2 id="一-BeanFactory和FactoryBean"><a href="#一-BeanFactory和FactoryBean" class="headerlink" title="一. BeanFactory和FactoryBean"></a>一. BeanFactory和FactoryBean</h2><p>先聊一聊BeanFactory和FactoryBean，期初我看源码的时候，看到这两个接口真是异常懵逼，他们的方法还很相似，都是获取一个Object。其实这两个接口八竿子打不着，九杆子能打着一点，这里就先讲一讲这两个接口各是干什么的。</p><h3 id="1-BeanFactory"><a href="#1-BeanFactory" class="headerlink" title="1. BeanFactory"></a>1. BeanFactory</h3><p>spring的总工厂，所有的bean的实例都保存在这个工厂中，并提供了各种不同的方法去获取各种的bean的实例。这个接口没啥好多说的，最核心的接口，等下我们会重点分析这个接口。</p><h3 id="2-FactoryBean"><a href="#2-FactoryBean" class="headerlink" title="2. FactoryBean"></a>2. FactoryBean</h3><p>从名字来看，首先这是一个Bean，然后这是一个工厂，其部分注释如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">* If a bean implements <span class="keyword">this</span></span><br><span class="line">* <span class="class"><span class="keyword">interface</span>, <span class="title">it</span> <span class="title">is</span> <span class="title">used</span> <span class="title">as</span> <span class="title">a</span> <span class="title">factory</span> <span class="title">for</span> <span class="title">an</span> <span class="title">object</span> <span class="title">to</span> <span class="title">expose</span>, <span class="title">not</span> <span class="title">directly</span> <span class="title">as</span> <span class="title">a</span></span></span><br><span class="line"><span class="class">* <span class="title">bean</span> <span class="title">instance</span> <span class="title">that</span> <span class="title">will</span> <span class="title">be</span> <span class="title">exposed</span> <span class="title">itself</span>.</span></span><br><span class="line"><span class="class">*</span></span><br><span class="line"><span class="class">* &lt;<span class="title">p</span>&gt;&lt;<span class="title">b</span>&gt;<span class="title">NB</span>: <span class="title">A</span> <span class="title">bean</span> <span class="title">that</span> <span class="keyword">implements</span> <span class="title">this</span> <span class="title">interface</span> <span class="title">cannot</span> <span class="title">be</span> <span class="title">used</span> <span class="title">as</span> <span class="title">a</span> <span class="title">normal</span> <span class="title">bean</span>.&lt;/<span class="title">b</span>&gt;</span></span><br><span class="line"><span class="class">* <span class="title">A</span> <span class="title">FactoryBean</span> <span class="title">is</span> <span class="title">defined</span> <span class="title">in</span> <span class="title">a</span> <span class="title">bean</span> <span class="title">style</span>, <span class="title">but</span> <span class="title">the</span> <span class="title">object</span> <span class="title">exposed</span> <span class="title">for</span> <span class="title">bean</span></span></span><br><span class="line"><span class="class">* <span class="title">references</span> (</span>&#123;<span class="meta">@link</span> #getObject()&#125;) is always the object that it creates.</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FactoryBean才是真正的我们熟悉的”工厂方法模式”，其实命名为Factory会更好，但是在spring中，所有的实体都是Bean，一个Factory也不例外是一个Bean，所以就命名为了FactoryBean。实现了这个接口的类就是一个工厂类，里面需要实现获取具体对象的逻辑。</p><h3 id="3-FactoryBean，工厂方法模式"><a href="#3-FactoryBean，工厂方法模式" class="headerlink" title="3. FactoryBean，工厂方法模式"></a>3. FactoryBean，工厂方法模式</h3><p>这里不会详细介绍什么是工厂模式，因为在进行spring源码阅读的时候会假定已经掌握了各种常用的设计模式。</p><p>那么FactoryBean是怎么使用工厂方法模式的呢？</p><p>FactoryBean有一个直接实现类：AbstractFactoryBean，里面实现了<code>T getObject() throws Exception</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Expose the singleton instance or create a new prototype instance.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #createInstance()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getEarlySingletonInterfaces()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isSingleton()) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>.initialized ? <span class="keyword">this</span>.singletonInstance : getEarlySingletonInstance());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> createInstance();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Template method that subclasses must override to construct</span></span><br><span class="line"><span class="comment"> * the object returned by this factory.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Invoked on initialization of this FactoryBean in case of</span></span><br><span class="line"><span class="comment"> * a singleton; else, on each &#123;<span class="doctag">@link</span> #getObject()&#125; call.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the object returned by this factory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception if an exception occurred during object creation</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getObject()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title">createInstance</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure><p>最后扔给了一个模板方法createInstance()去完成具体的实例的创建工作，这就是一个标准的工厂模式。</p><h2 id="二-How-getBean-works"><a href="#二-How-getBean-works" class="headerlink" title="二. How getBean() works."></a>二. How getBean() works.</h2><p>BeanFactory接口的集大成者就是DefaultListableBeanFactory，整个Bean的实例化过程、实例化策略等等内容，都在DefaultListableBeanFactory以及其父类AbstractAutowireCapableBeanFactory和AbstractBeanFactory中，故也是我们研究的重点对象。</p><img src="https://raw.githubusercontent.com/zhengrenjie/PicGo/master/img/bf.png"/><p>这个继承关系也是没谁了。。</p><h3 id="1-AliasRegistry-amp-SimpleAliasRegistry"><a href="#1-AliasRegistry-amp-SimpleAliasRegistry" class="headerlink" title="1. AliasRegistry &amp; SimpleAliasRegistry"></a>1. AliasRegistry &amp; SimpleAliasRegistry</h3><p>bean可能有各种别名，这个接口用来提供给一个Bean添加一些别名，并提供根据某个别名查找一个Bean的逻辑。所有的别名引用关系保存在一个map中，取的时候是递归算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SimpleAliasRegistry.java</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transitively retrieve all aliases for the given name.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name the target name to find aliases for</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> result the resulting aliases list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">retrieveAliases</span><span class="params">(String name, List&lt;String&gt; result)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.aliasMap.forEach((alias, registeredName) -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (registeredName.equals(name)) &#123;</span><br><span class="line">      result.add(alias);</span><br><span class="line">      retrieveAliases(alias, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-DefaultSingletonBeanRegistry"><a href="#2-DefaultSingletonBeanRegistry" class="headerlink" title="2. DefaultSingletonBeanRegistry"></a>2. DefaultSingletonBeanRegistry</h3><p>提供了保存单例Bean的Map、Set等集合，不仅仅是完全体的Bean，也有正在创建中的Bean，以及Bean之间的依赖关系都在这里。看看这个类的属性，就知道它的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Cache of singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Cache of early singleton objects: bean name to bean instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Set of registered singletons, containing the bean names in registration order. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; registeredSingletons = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Names of beans that are currently in creation. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; singletonsCurrentlyInCreation =</span><br><span class="line">        Collections.newSetFromMap(<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Names of beans currently excluded from in creation checks. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; inCreationCheckExclusions =</span><br><span class="line">        Collections.newSetFromMap(<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/** List of suppressed Exceptions, available for associating related causes. */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;Exception&gt; suppressedExceptions;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Flag that indicates whether we&#x27;re currently within destroySingletons. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> singletonsCurrentlyInDestruction = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Disposable bean instances: bean name to disposable instance. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; disposableBeans = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Map between containing bean names: bean name to Set of bean names that the bean contains. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;String&gt;&gt; containedBeanMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Map between dependent bean names: bean name to Set of dependent bean names. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;String&gt;&gt; dependentBeanMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Map between depending bean names: bean name to Set of bean names for the bean&#x27;s dependencies. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Set&lt;String&gt;&gt; dependenciesForBeanMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">64</span>);</span><br></pre></td></tr></table></figure><h3 id="3-FactoryBeanRegistrySupport"><a href="#3-FactoryBeanRegistrySupport" class="headerlink" title="3. FactoryBeanRegistrySupport"></a>3. FactoryBeanRegistrySupport</h3><p>这个类提供了对FactoryBean的支持，有一些bean不是直接创建的，而是通过FactoryBean工厂创建的，我们在上文讲过了FactoryBean。这个类的主要功能就是从FactoryBean中调用getObject方法拿到工厂创建出来的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Obtain an object to expose from the given FactoryBean.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> factory the FactoryBean instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the object obtained from the FactoryBean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanCreationException if FactoryBean object creation failed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.beans.factory.FactoryBean#getObject()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">doGetObjectFromFactoryBean</span><span class="params">(<span class="keyword">final</span> FactoryBean&lt;?&gt; factory, <span class="keyword">final</span> String beanName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Object object;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            AccessControlContext acc = getAccessControlContext();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                object = AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) factory::getObject, acc);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">                <span class="keyword">throw</span> pae.getException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 就是这句，调用了FactoryBean的getObject()方法，拿到工厂创建的实例。</span></span><br><span class="line">            object = factory.getObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>很简单的一个类，不多讲了，这个类的代码也很简单，主要做了各种异常控制、权限检查、log打印，真正的关键代码只有<code>object = factory.getObject();</code>这一行。</p><h3 id="4-AbstractBeanFactory-amp-AbstractAutowireCapableBeanFactory"><a href="#4-AbstractBeanFactory-amp-AbstractAutowireCapableBeanFactory" class="headerlink" title="4. AbstractBeanFactory &amp; AbstractAutowireCapableBeanFactory"></a>4. AbstractBeanFactory &amp; AbstractAutowireCapableBeanFactory</h3><p>里面实现了BeanFactory中的核心方法：getBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an instance, which may be shared or independent, of the specified bean.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">      <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">      checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">      String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">      <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">          <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                <span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          registerDependentBean(dep, beanName);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            getBean(dep);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                <span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// Create bean instance.</span></span><br><span class="line">      <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">            <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">            <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">            destroySingleton(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面如果设置了ParentBeanFactory，那么调用ParentBeanFactory去getBean。</p><p>先根据beanName拿到RootBeanDefinition，然后递归解析bean的所有依赖，朋友们可以想一下这个过程，最后保证当前所有的依赖都已经创建了，然后开始准备创建当前bean。</p><p>可以看到创建bean的工作委托给了createBean，这个方法在子类AbstractAutowireCapableBeanFactory中实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">      <span class="comment">// 真正创建bean的类</span></span><br><span class="line">      Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    ... <span class="comment">// 省略了其他代码</span></span><br><span class="line">      instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">      populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">      exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Initialize the given bean instance, applying factory callbacks</span></span><br><span class="line"><span class="comment">   * as well as init methods and bean post processors.</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;Called from &#123;<span class="doctag">@link</span> #createBean&#125; for traditionally defined beans,</span></span><br><span class="line"><span class="comment">   * and from &#123;<span class="doctag">@link</span> #initializeBean&#125; for existing bean instances.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">        invokeAwareMethods(beanName, bean);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;, getAccessControlContext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      invokeAwareMethods(beanName, bean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object wrappedBean = bean;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">      wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">          (mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">          beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">      wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里就非常清晰了：</p><blockquote><p>首先委托给了真正的创建方法：doCreateBean</p><p>doCreateBean实例化Bean分三步走：</p><ol><li><p>doCreateBean中首先调用createBeanInstance实例化Bean，这个时候Bean被实例化了。createBeanInstance中根据各种不同的配置，采用不同的构造函数进行实例化。</p></li><li><p>doCreateBean中然后调用populateBean方法，改方法将Bean的各种依赖通过BeanWrapper提供的对属性的编辑方法，设置到Bean中。这一步完成了Bean的依赖的组装。</p></li><li><p>doCreateBean最后调用了initializeBean，意为初始化Bean，这个时候的Bean已经是一个Object实例，并且Bean中通过@Autowire设置的依赖也全部设置完毕。但是最后还有一些初始化工作要做，看代码：首先，如何这个Bean实现了各种Aware接口，则依次调用这些接口的set方法设置信息；然后调用所有的BeanPostProcessors中的Before方法；然后调用通过”init-method”指定的init方法；最后调用所有BeanPostProcessors中的After方法。</p></li></ol></blockquote><p>最后，这些方法一层一层向上返回了初始化完成的Bean实例。</p><p>返回到AbstractBeanFactory中后调用了getObjectForBeanInstance()，检查返回的Bean Instance是否是FactoryBean，如果是，则调用getObject方法获取真正的实例。</p><p>创建完后的Bean会放进各种Map中，前面已经讲过了，下次再次getBean的时候，就是从缓存中获取了。</p><h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h2><p>我们没有讲Spring是怎么扫描并将各种标注了@Service的Class转换成BeanDefinition的，上面的过程是在所有的BeanDefinition已经生成并存储在内存中之后执行的。BeanFactory有一个实现类叫做XmlBeanFactory，虽然已经被遗弃了，但是里面展示了如何将application.xml中定义的Bean转化成BeanDefinition的过程，这些都不是这篇文章的重点。这篇文章重点讲解了BeanFactory的每一级继承结构，以及调用getBean的时候发生了什么，Bean的实例是如何被创建并返回的，Aware接口是什么时候被调用的。</p><p>在代码中我们可以清晰的看到一个bean被初始化的生命周期：实例化-&gt;组装各种依赖-&gt;调用Aware接口方法-&gt;调用BeanPostProcessor的before方法-&gt;指定的”init-method”方法-&gt;调用BeanPostProcessor的after方法。关于生命周期，《Spring In Action》这本书中有详细讲解。</p><p>其实到这里spring-beans模块的核心部分就已经讲完了，里面还有一些接口如：Aware、InitializingBean、DisposableBean、BeanReference等，这些都是常用接口，但是这些接口没啥好讲的，都是基于实践意义上的接口。关于RootBeanDefinition和ChildBeanDefinition是如何合并的这里也没有多说，比较简单，基于java的继承和多态机制仿的一个工能，所以也不说了。</p><p>之后可能会讲一讲spring-context包和spring-mvc包中的一些常用接口，但是我认为spring的灵魂部分，到这里算是讲完了。</p><p>其实究其本质呢，bean的初始化底层依赖两个工具，那就是反射和自省，用反射实例化Bean以及调用一些方法（如init-method），用自省去设置Bean的各种属性。中间做的各种工作，都是对这两个底层调用的封装，BeanWrapper就是对自省功能的封装，BeanDefinition是对Bean的设置，BeanFactory是对反射功能的封装。</p><p>除了spring的主体功能之外，还有异常的封装、log的打印等都是值得好好研究和学习的地方，以后有时间我也会给朋友们写一写。</p><p>如果文章中有任何不对的地方，请您不吝赐教，也欢迎加我微信交流~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前置&quot;&gt;&lt;a href=&quot;#前置&quot; class=&quot;headerlink&quot; title=&quot;前置&quot;&gt;&lt;/a&gt;前置&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.jelliclecat.cn/articles/Spring/Spring-beans-1.htm</summary>
      
    
    
    
    <category term="Spring" scheme="https://www.jelliclecat.cn/categories/Spring/"/>
    
    
    <category term="Java" scheme="https://www.jelliclecat.cn/tags/Java/"/>
    
    <category term="Spring" scheme="https://www.jelliclecat.cn/tags/Spring/"/>
    
  </entry>
  
</feed>
